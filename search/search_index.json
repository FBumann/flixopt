{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"flixOpt: Energy and Material Flow Optimization Framework","text":"<p>flixOpt is a Python-based optimization framework designed to tackle energy and material flow problems using mixed-integer linear programming (MILP). Combining flexibility and efficiency, it provides a powerful platform for both dispatch and investment optimization challenges.</p>"},{"location":"#introduction","title":"\ud83d\ude80 Introduction","text":"<p>flixOpt was developed by TU Dresden as part of the SMARTBIOGRID project, funded by the German Federal Ministry for Economic Affairs and Energy. Building on the Matlab-based flixOptMat framework, flixOpt also incorporates concepts from oemof/solph.</p> <p>Although flixOpt is in its early stages, it is fully functional and ready for experimentation. Feedback and collaboration are highly encouraged to help shape its future.</p>"},{"location":"#key-features","title":"\ud83c\udf1f Key Features","text":"<ul> <li>High-level Interface with low-level control</li> <li>User-friendly interface for defining energy systems</li> <li>Fine-grained control for advanced configurations</li> <li> <p>Pre-defined components like CHP, Heat Pump, Cooling Tower, etc.</p> </li> <li> <p>Investment Optimization</p> </li> <li>Combined dispatch and investment optimization</li> <li>Size and discrete investment decisions</li> <li> <p>Integration with On/Off variables and constraints</p> </li> <li> <p>Multiple Effects</p> </li> <li>Couple effects (e.g., specific CO2 costs)</li> <li>Set constraints (e.g., max CO2 emissions)</li> <li> <p>Easily switch optimization targets (e.g., costs vs CO2)</p> </li> <li> <p>Calculation Modes</p> </li> <li>Full Mode - Exact solutions with high computational requirements</li> <li>Segmented Mode - Speed up complex systems with variable time overlap</li> <li>Aggregated Mode - Typical periods for large-scale simulations</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>Install flixOpt directly using pip:</p> <pre><code>pip install git+https://github.com/flixOpt/flixOpt.git\n</code></pre> <p>For full functionality including visualization and time series aggregation:</p> <pre><code>pip install \"flixOpt[full] @ git+https://github.com/flixOpt/flixOpt.git\"\n</code></pre>"},{"location":"#quick-example","title":"\ud83d\udda5\ufe0f Quick Example","text":"<pre><code>import flixOpt as fo\nimport numpy as np\n\n# Create timesteps\ntime_series = fo.create_datetime_array('2023-01-01', steps=24, freq='1h')\nsystem = fo.FlowSystem(time_series)\n\n# Create buses\nheat_bus = fo.Bus(\"Heat\")\nelectricity_bus = fo.Bus(\"Electricity\")\n\n# Create flows\nheat_demand = fo.Flow(\n    label=\"heat_demand\",\n    bus=heat_bus,\n    fixed_relative_profile=100*np.sin(np.linspace(0, 2*np.pi, 24))**2 + 50\n)\n\n# Create a heat pump component\nheat_pump = fo.linear_converters.HeatPump(\n    label=\"HeatPump\",\n    COP=3.0,\n    P_el=fo.Flow(\"power\", electricity_bus),\n    Q_th=fo.Flow(\"heat\", heat_bus)\n)\n\n# Add everything to the system\nsystem.add_elements(heat_bus, electricity_bus)\nsystem.add_components(heat_pump)\n</code></pre>"},{"location":"#how-it-works","title":"\u2699\ufe0f How It Works","text":"<p>flixOpt transforms your energy system model into a mathematical optimization problem, solves it using state-of-the-art solvers, and returns the optimal operation strategy and investment decisions.</p>"},{"location":"#compatible-solvers","title":"\ud83d\udee0\ufe0f Compatible Solvers","text":"<p>flixOpt works with various solvers:</p> <ul> <li>HiGHS (installed by default)</li> <li>CBC</li> <li>GLPK</li> <li>Gurobi</li> <li>CPLEX</li> </ul>"},{"location":"#citation","title":"\ud83d\udcdd Citation","text":"<p>If you use flixOpt in your research or project, please cite:</p> <ul> <li>Main Citation: DOI:10.18086/eurosun.2022.04.07</li> <li>Short Overview: DOI:10.13140/RG.2.2.14948.24969</li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Getting Started</li> <li>Concepts &amp; Math</li> <li>Examples</li> <li>API-Reference</li> <li>Contribute</li> </ul>"},{"location":"contribute/","title":"Contributing to the Project","text":"<p>We warmly welcome contributions from the community! This guide will help you get started with contributing to our project.</p>"},{"location":"contribute/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository <code>git clone https://github.com/flixOpt/flixopt.git</code></li> <li>Install the development dependencies <code>pip install -editable .[dev, docs]</code></li> <li>Run <code>pytest</code> and <code>ruff check .</code> to ensure your code passes all tests</li> </ol>"},{"location":"contribute/#documentation","title":"Documentation","text":"<p>flixOpt uses mkdocs to generate documentation. To preview the documentation locally, run <code>mkdocs serve</code> in the root directory.</p>"},{"location":"contribute/#helpful-commands","title":"Helpful Commands","text":"<ul> <li><code>mkdocs serve</code> to preview the documentation locally. Navigate to <code>http://127.0.0.1:8000/</code> to view the documentation.</li> <li><code>pytest</code> to run the test suite (You can also run the provided python script <code>run_all_test.py</code>)</li> <li><code>ruff check .</code> to run the linter</li> <li><code>ruff check . --fix</code> to automatically fix linting issues</li> </ul>"},{"location":"contribute/#best-practices","title":"Best practices","text":""},{"location":"contribute/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Write clear, commented code</li> <li>Include type hints</li> <li>Create or update tests for new functionality</li> <li>Ensure 100% test coverage for new code</li> </ul>"},{"location":"contribute/#branches","title":"Branches","text":"<p>As we start to think flixOpt in Releases, we decided to introduce multiple dev-branches instead of only one: Following the Semantic Versioning guidelines, we introduced: - <code>next/patch</code>: This is where all pull requests for the next patch release (1.0.x) go. - <code>next/minor</code>: This is where all pull requests for the next minor release (1.x.0) go. - <code>next/major</code>: This is where all pull requests for the next major release (x.0.0) go.</p> <p>Everything else remains in <code>feature/...</code>-branches.</p>"},{"location":"contribute/#pull-requests","title":"Pull requests","text":"<p>Every feature or bugfix should be merged into one of the 3 release branches, using Squash and merge or a regular single commit. At some point, <code>next/minor</code> or <code>next/major</code> will get merged into <code>main</code> using a regular Merge  (not squash). This ensures that Features are kept separate, and the <code>next/...</code>branches stay in synch with <code>`main</code>.</p>"},{"location":"contribute/#releases","title":"Releases","text":"<p>As stated, we follow Semantic Versioning. Right after one of the 3 release branches is merged into main, a Tag should be added to the merge commit and pushed to the main branch. The tag has the form <code>v1.2.3</code>. With this tag,  a release with Release Notes must be created. </p> <p>This is our current best practice</p>"},{"location":"getting-started/","title":"Getting Started with flixOpt","text":"<p>This guide will help you install flixOpt, understand its basic concepts, and run your first optimization model.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#basic-installation","title":"Basic Installation","text":"<p>Install flixOpt directly into your environment using pip:</p> <pre><code>pip install git+https://github.com/flixOpt/flixOpt.git\n</code></pre> <p>This provides the core functionality with the HiGHS solver included.</p>"},{"location":"getting-started/#full-installation","title":"Full Installation","text":"<p>For all features including interactive network visualizations and time series aggregation:</p> <pre><code>pip install \"flixOpt[full] @ git+https://github.com/flixOpt/flixOpt.git\"\n</code></pre>"},{"location":"getting-started/#basic-workflow","title":"Basic Workflow","text":"<p>Working with flixOpt follows a general pattern:</p> <ol> <li>Create a <code>FlowSystem</code> with a time series</li> <li>Define <code>Effects</code> (costs, emissions, etc.)</li> <li>Define <code>Buses</code> as connection points in your system</li> <li>Add <code>Components</code> like converters, storage, sources/sinks with their Flows</li> <li>Run <code>Calculations</code> to optimize your system</li> <li>Analyze <code>Results</code> using built-in or external visualization tools</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've installed flixOpt and understand the basic workflow, you can:</p> <ul> <li>Learn about the core concepts of flixOpt</li> <li>Explore some examples</li> <li>Check the API reference for detailed documentation</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section contains the documentation for all modules and classes in flixOpt. For more information on how to use the classes and functions, see the Concepts &amp; Math section.</p>"},{"location":"api-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>aggregation</li> <li>calculation</li> <li>commons</li> <li>components</li> <li>config</li> <li>core</li> <li>effects</li> <li>elements</li> <li>features</li> <li>flow_system</li> <li>interface</li> <li>linear_converters</li> <li>math_modeling</li> <li>plotting</li> <li>results</li> <li>solvers</li> <li>structure</li> <li>utils</li> </ul>"},{"location":"api-reference/aggregation/","title":"aggregation","text":""},{"location":"api-reference/aggregation/#flixOpt.aggregation","title":"flixOpt.aggregation","text":"<p>This module contains the Aggregation functionality for the flixOpt framework. Through this, aggregating TimeSeriesData is possible.</p>"},{"location":"api-reference/aggregation/#flixOpt.aggregation-classes","title":"Classes","text":""},{"location":"api-reference/aggregation/#flixOpt.aggregation.Aggregation","title":"Aggregation","text":"<pre><code>Aggregation(original_data: DataFrame, hours_per_time_step: Skalar, hours_per_period: Skalar, nr_of_periods: int = 8, weights: Dict[str, float] = None, time_series_for_high_peaks: List[str] = None, time_series_for_low_peaks: List[str] = None)\n</code></pre> <p>aggregation organizing class</p> <p>Write a docstring please</p> <p>Parameters:</p> Name Type Description Default <code>timeseries</code> <p>timeseries of the data with a datetime index</p> required"},{"location":"api-reference/aggregation/#flixOpt.aggregation.Aggregation-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixOpt.aggregation.Aggregation.cluster","title":"cluster","text":"<pre><code>cluster() -&gt; None\n</code></pre> <p>Durchf\u00fchrung der Zeitreihenaggregation</p>"},{"location":"api-reference/aggregation/#flixOpt.aggregation.Aggregation.get_cluster_indices","title":"get_cluster_indices","text":"<pre><code>get_cluster_indices() -&gt; Dict[str, List[np.ndarray]]\n</code></pre> <p>Generates a dictionary that maps each cluster to a list of index vectors representing the time steps assigned to that cluster for each period.</p> <p>Returns:     dict: {cluster_0: [index_vector_3, index_vector_7, ...],            cluster_1: [index_vector_1],            ...}</p>"},{"location":"api-reference/aggregation/#flixOpt.aggregation.Aggregation.get_equation_indices","title":"get_equation_indices","text":"<pre><code>get_equation_indices(skip_first_index_of_period: bool = True) -&gt; Tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Generates pairs of indices for the equations by comparing index vectors of the same cluster. If <code>skip_first_index_of_period</code> is True, the first index of each period is skipped.</p> <p>Args:     skip_first_index_of_period (bool): Whether to include or skip the first index of each period.</p> <p>Returns:     Tuple[np.ndarray, np.ndarray]: Two arrays of indices.</p>"},{"location":"api-reference/aggregation/#flixOpt.aggregation.TimeSeriesCollection","title":"TimeSeriesCollection","text":"<pre><code>TimeSeriesCollection(time_series_list: List[TimeSeries])\n</code></pre>"},{"location":"api-reference/aggregation/#flixOpt.aggregation.AggregationParameters","title":"AggregationParameters","text":"<pre><code>AggregationParameters(hours_per_period: float, nr_of_periods: int, fix_storage_flows: bool, aggregate_data_and_fix_non_binary_vars: bool, percentage_of_period_freedom: float = 0, penalty_of_period_freedom: float = 0, time_series_for_high_peaks: List[TimeSeriesData] = None, time_series_for_low_peaks: List[TimeSeriesData] = None)\n</code></pre> <p>Initializes aggregation parameters for time series data</p> <p>Parameters:</p> Name Type Description Default <code>hours_per_period</code> <code>float</code> <p>Duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>Number of typical periods to use in the aggregation.</p> required <code>fix_storage_flows</code> <code>bool</code> <p>Whether to aggregate storage flows (load/unload); if other flows are fixed, fixing storage flows is usually not required.</p> required <code>aggregate_data_and_fix_non_binary_vars</code> <code>bool</code> <p>Whether to aggregate all time series data, which allows to fix all time series variables (like flow_rate), or only fix binary variables. If False non time_series data is changed!! If True, the mathematical Problem is simplified even further.</p> required <code>percentage_of_period_freedom</code> <code>float</code> <p>Specifies the maximum percentage (0\u2013100) of binary values within each period that can deviate as \"free variables\", chosen by the solver (default is 0). This allows binary variables to be 'partly equated' between aggregated periods.</p> <code>0</code> <code>penalty_of_period_freedom</code> <code>float</code> <p>The penalty associated with each \"free variable\"; defaults to 0. Added to Penalty</p> <code>0</code> <code>time_series_for_high_peaks</code> <code>list of TimeSeriesData</code> <p>List of time series to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>list of TimeSeriesData</code> <p>List of time series to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/aggregation/#flixOpt.aggregation.AggregationParameters-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixOpt.aggregation.AggregationModel","title":"AggregationModel","text":"<pre><code>AggregationModel(aggregation_parameters: AggregationParameters, flow_system: FlowSystem, aggregation_data: Aggregation, components_to_clusterize: Optional[List[Component]])\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>The AggregationModel holds equations and variables related to the Aggregation of a FLowSystem. It creates Equations that equates indices of variables, and introduces penalties related to binary variables, that escape the equation to their related binaries in other periods</p> <p>Modeling-Element for \"index-equating\"-equations</p>"},{"location":"api-reference/aggregation/#flixOpt.aggregation.AggregationModel-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixOpt.aggregation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/","title":"calculation","text":""},{"location":"api-reference/calculation/#flixOpt.calculation","title":"flixOpt.calculation","text":"<p>This module contains the Calculation functionality for the flixOpt framework. It is used to calculate a SystemModel for a given FlowSystem through a solver. There are three different Calculation types:     1. FullCalculation: Calculates the SystemModel for the full FlowSystem     2. AggregatedCalculation: Calculates the SystemModel for the full FlowSystem, but aggregates the TimeSeriesData.         This simplifies the mathematical model and usually speeds up the solving process.     3. SegmentedCalculation: Solves a SystemModel for each individual Segment of the FlowSystem.</p>"},{"location":"api-reference/calculation/#flixOpt.calculation-classes","title":"Classes","text":""},{"location":"api-reference/calculation/#flixOpt.calculation.Calculation","title":"Calculation","text":"<pre><code>Calculation(name, flow_system: FlowSystem, modeling_language: Literal['pyomo', 'cvxpy'] = 'pyomo', time_indices: Optional[Union[range, List[int]]] = None)\n</code></pre> <p>class for defined way of solving a flow_system optimization</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>modeling_language</code> <code>'pyomo','cvxpy' (not implemeted yet)</code> <p>choose optimization modeling language</p> <code>'pyomo'</code> <code>time_indices</code> <code>List[int] or None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixOpt.calculation.Calculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixOpt.calculation.FullCalculation","title":"FullCalculation","text":"<pre><code>FullCalculation(name, flow_system: FlowSystem, modeling_language: Literal['pyomo', 'cvxpy'] = 'pyomo', time_indices: Optional[Union[range, List[int]]] = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>class for defined way of solving a flow_system optimization</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>modeling_language</code> <code>'pyomo','cvxpy' (not implemeted yet)</code> <p>choose optimization modeling language</p> <code>'pyomo'</code> <code>time_indices</code> <code>List[int] or None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixOpt.calculation.FullCalculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixOpt.calculation.AggregatedCalculation","title":"AggregatedCalculation","text":"<pre><code>AggregatedCalculation(name, flow_system: FlowSystem, aggregation_parameters: AggregationParameters, components_to_clusterize: Optional[List[Component]] = None, modeling_language: Literal['pyomo', 'cvxpy'] = 'pyomo', time_indices: Optional[Union[range, List[int]]] = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>class for defined way of solving a flow_system optimization</p> <p>Class for Optimizing the FLowSystem including:     1. Aggregating TimeSeriesData via typical periods using tsam.     2. Equalizing variables of typical periods.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>aggregation_parameters</code> <code>AggregationParameters</code> <p>Parameters for aggregation. See documentation of AggregationParameters class.</p> required <code>components_to_clusterize</code> <code>Optional[List[Component]]</code> <p>List of Components to perform aggregation on. If None, then all components are aggregated. This means, teh variables in the components are equalized to each other, according to the typical periods computed in the DataAggregation</p> <code>None</code> <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>modeling_language</code> <code>'pyomo','cvxpy' (not implemeted yet)</code> <p>choose optimization modeling language</p> <code>'pyomo'</code> <code>time_indices</code> <code>List[int] or None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixOpt.calculation.AggregatedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixOpt.calculation.SegmentedCalculation","title":"SegmentedCalculation","text":"<pre><code>SegmentedCalculation(name, flow_system: FlowSystem, segment_length: int, overlap_length: int, modeling_language: Literal['pyomo', 'cvxpy'] = 'pyomo', time_indices: Optional[Union[range, list[int]]] = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>Dividing and Modeling the problem in (overlapping) segments. The final values of each Segment are recognized by the following segment, effectively coupling charge_states and flow_rates between segments. Because of this intersection, both modeling and solving is done in one step</p> <p>Take care: Parameters like InvestParameters, sum_of_flow_hours and other restrictions over the total time_series don't really work in this Calculation. Lower bounds to such SUMS can lead to weird results. This is NOT yet explicitly checked for...</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>segment_length</code> <code>int</code> <p>The number of time_steps per individual segment (without the overlap)</p> required <code>overlap_length</code> <code>int</code> <p>The number of time_steps that are added to each individual model. Used for better results of storages)</p> required <code>modeling_language</code> <code>'pyomo', 'cvxpy' (not implemeted yet)</code> <p>choose optimization modeling language</p> <code>'pyomo'</code> <code>time_indices</code> <code>List[int] or None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixOpt.calculation.SegmentedCalculation-attributes","title":"Attributes","text":""},{"location":"api-reference/calculation/#flixOpt.calculation.SegmentedCalculation.start_values_of_segments","title":"start_values_of_segments  <code>property</code>","text":"<pre><code>start_values_of_segments: Dict[str, Dict[str, Any]]\n</code></pre> <p>Gives an overview of the start values of all Segments</p>"},{"location":"api-reference/calculation/#flixOpt.calculation.SegmentedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixOpt.calculation.SegmentedCalculation.results","title":"results","text":"<pre><code>results(combined_arrays: bool = False, combined_scalars: bool = False, individual_results: bool = False) -&gt; Dict[str, Union[Numeric, Dict[str, Numeric]]]\n</code></pre> <p>Retrieving the results of a Segmented Calculation is not as straight forward as with other Calculation types. You have 3 options: 1.  combined_arrays:     Retrieve the combined array Results of all Segments as 'combined_arrays'. All result arrays ar concatenated,     taking care of removing the overlap. These results can be directly compared to other Calculation results.     Unfortunately, Scalar values like the total of effects can not be combined in a deterministic way.     Rather convert the time series effect results to a sum yourself. 2.  combined_scalars:     Retrieve the combined scalar Results of all Segments. All Scalar Values like the total of effects are     combined and stored in a List. Take care that the total of multiple Segment is not equivalent to the     total of the total timeSeries, as it includes the Overlap! 3.  individual_results:     Retrieve the individual results of each Segment</p>"},{"location":"api-reference/calculation/#flixOpt.calculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/","title":"commons","text":""},{"location":"api-reference/commons/#flixOpt.commons","title":"flixOpt.commons","text":"<p>This module makes the commonly used classes and functions available in the flixOpt framework.</p>"},{"location":"api-reference/commons/#flixOpt.commons-classes","title":"Classes","text":""},{"location":"api-reference/commons/#flixOpt.commons.AggregationParameters","title":"AggregationParameters","text":"<pre><code>AggregationParameters(hours_per_period: float, nr_of_periods: int, fix_storage_flows: bool, aggregate_data_and_fix_non_binary_vars: bool, percentage_of_period_freedom: float = 0, penalty_of_period_freedom: float = 0, time_series_for_high_peaks: List[TimeSeriesData] = None, time_series_for_low_peaks: List[TimeSeriesData] = None)\n</code></pre> <p>Initializes aggregation parameters for time series data</p> <p>Parameters:</p> Name Type Description Default <code>hours_per_period</code> <code>float</code> <p>Duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>Number of typical periods to use in the aggregation.</p> required <code>fix_storage_flows</code> <code>bool</code> <p>Whether to aggregate storage flows (load/unload); if other flows are fixed, fixing storage flows is usually not required.</p> required <code>aggregate_data_and_fix_non_binary_vars</code> <code>bool</code> <p>Whether to aggregate all time series data, which allows to fix all time series variables (like flow_rate), or only fix binary variables. If False non time_series data is changed!! If True, the mathematical Problem is simplified even further.</p> required <code>percentage_of_period_freedom</code> <code>float</code> <p>Specifies the maximum percentage (0\u2013100) of binary values within each period that can deviate as \"free variables\", chosen by the solver (default is 0). This allows binary variables to be 'partly equated' between aggregated periods.</p> <code>0</code> <code>penalty_of_period_freedom</code> <code>float</code> <p>The penalty associated with each \"free variable\"; defaults to 0. Added to Penalty</p> <code>0</code> <code>time_series_for_high_peaks</code> <code>list of TimeSeriesData</code> <p>List of time series to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>list of TimeSeriesData</code> <p>List of time series to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/commons/#flixOpt.commons.AggregationParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.AggregatedCalculation","title":"AggregatedCalculation","text":"<pre><code>AggregatedCalculation(name, flow_system: FlowSystem, aggregation_parameters: AggregationParameters, components_to_clusterize: Optional[List[Component]] = None, modeling_language: Literal['pyomo', 'cvxpy'] = 'pyomo', time_indices: Optional[Union[range, List[int]]] = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>class for defined way of solving a flow_system optimization</p> <p>Class for Optimizing the FLowSystem including:     1. Aggregating TimeSeriesData via typical periods using tsam.     2. Equalizing variables of typical periods.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>aggregation_parameters</code> <code>AggregationParameters</code> <p>Parameters for aggregation. See documentation of AggregationParameters class.</p> required <code>components_to_clusterize</code> <code>Optional[List[Component]]</code> <p>List of Components to perform aggregation on. If None, then all components are aggregated. This means, teh variables in the components are equalized to each other, according to the typical periods computed in the DataAggregation</p> <code>None</code> <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>modeling_language</code> <code>'pyomo','cvxpy' (not implemeted yet)</code> <p>choose optimization modeling language</p> <code>'pyomo'</code> <code>time_indices</code> <code>List[int] or None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code>"},{"location":"api-reference/commons/#flixOpt.commons.AggregatedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.FullCalculation","title":"FullCalculation","text":"<pre><code>FullCalculation(name, flow_system: FlowSystem, modeling_language: Literal['pyomo', 'cvxpy'] = 'pyomo', time_indices: Optional[Union[range, List[int]]] = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>class for defined way of solving a flow_system optimization</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>modeling_language</code> <code>'pyomo','cvxpy' (not implemeted yet)</code> <p>choose optimization modeling language</p> <code>'pyomo'</code> <code>time_indices</code> <code>List[int] or None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code>"},{"location":"api-reference/commons/#flixOpt.commons.FullCalculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.SegmentedCalculation","title":"SegmentedCalculation","text":"<pre><code>SegmentedCalculation(name, flow_system: FlowSystem, segment_length: int, overlap_length: int, modeling_language: Literal['pyomo', 'cvxpy'] = 'pyomo', time_indices: Optional[Union[range, list[int]]] = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>Dividing and Modeling the problem in (overlapping) segments. The final values of each Segment are recognized by the following segment, effectively coupling charge_states and flow_rates between segments. Because of this intersection, both modeling and solving is done in one step</p> <p>Take care: Parameters like InvestParameters, sum_of_flow_hours and other restrictions over the total time_series don't really work in this Calculation. Lower bounds to such SUMS can lead to weird results. This is NOT yet explicitly checked for...</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>segment_length</code> <code>int</code> <p>The number of time_steps per individual segment (without the overlap)</p> required <code>overlap_length</code> <code>int</code> <p>The number of time_steps that are added to each individual model. Used for better results of storages)</p> required <code>modeling_language</code> <code>'pyomo', 'cvxpy' (not implemeted yet)</code> <p>choose optimization modeling language</p> <code>'pyomo'</code> <code>time_indices</code> <code>List[int] or None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code>"},{"location":"api-reference/commons/#flixOpt.commons.SegmentedCalculation-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixOpt.commons.SegmentedCalculation.start_values_of_segments","title":"start_values_of_segments  <code>property</code>","text":"<pre><code>start_values_of_segments: Dict[str, Dict[str, Any]]\n</code></pre> <p>Gives an overview of the start values of all Segments</p>"},{"location":"api-reference/commons/#flixOpt.commons.SegmentedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.SegmentedCalculation.results","title":"results","text":"<pre><code>results(combined_arrays: bool = False, combined_scalars: bool = False, individual_results: bool = False) -&gt; Dict[str, Union[Numeric, Dict[str, Numeric]]]\n</code></pre> <p>Retrieving the results of a Segmented Calculation is not as straight forward as with other Calculation types. You have 3 options: 1.  combined_arrays:     Retrieve the combined array Results of all Segments as 'combined_arrays'. All result arrays ar concatenated,     taking care of removing the overlap. These results can be directly compared to other Calculation results.     Unfortunately, Scalar values like the total of effects can not be combined in a deterministic way.     Rather convert the time series effect results to a sum yourself. 2.  combined_scalars:     Retrieve the combined scalar Results of all Segments. All Scalar Values like the total of effects are     combined and stored in a List. Take care that the total of multiple Segment is not equivalent to the     total of the total timeSeries, as it includes the Overlap! 3.  individual_results:     Retrieve the individual results of each Segment</p>"},{"location":"api-reference/commons/#flixOpt.commons.LinearConverter","title":"LinearConverter","text":"<pre><code>LinearConverter(label: str, inputs: List[Flow], outputs: List[Flow], on_off_parameters: OnOffParameters = None, conversion_factors: List[Dict[Flow, Numeric_TS]] = None, segmented_conversion_factors: Dict[Flow, List[Tuple[Numeric_TS, Numeric_TS]]] = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Converts one FLow into another via linear conversion factors</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>inputs</code> <code>input flows.</code> required <code>outputs</code> <code>output flows.</code> required <code>on_off_parameters</code> <code>OnOffParameters</code> <code>None</code> <code>conversion_factors</code> <code>linear relation between flows.</code> <p>Either 'conversion_factors' or 'segmented_conversion_factors' can be used! example heat pump:</p> <code>None</code> <code>segmented_conversion_factors</code> <code> Segmented linear relation between flows.</code> <p>Each Flow gets a List of Segments assigned. If FLows need to be 0 (or Off), include a \"Zero-Segment\" \"(0, 0)\", or use on_off_parameters Either 'segmented_conversion_factors' or 'conversion_factors' can be used! --&gt; \"gaps\" can be expressed by a segment not starting at the end of the prior segment : [(1,3), (4,5)] --&gt; \"points\" can expressed as segment with same begin and end : [(3,3), (4,4)]</p> <code>None</code>"},{"location":"api-reference/commons/#flixOpt.commons.LinearConverter-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.LinearConverter.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.Sink","title":"Sink","text":"<pre><code>Sink(label: str, sink: Flow, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>constructor of sink</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of sink.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>sink</code> <code>Flow</code> <p>input-flow of sink</p> required"},{"location":"api-reference/commons/#flixOpt.commons.Sink-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.Sink.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.Source","title":"Source","text":"<pre><code>Source(label: str, source: Flow, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of source</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>source</code> <code>Flow</code> <p>output-flow of source</p> required"},{"location":"api-reference/commons/#flixOpt.commons.Source-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.Source.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.SourceAndSink","title":"SourceAndSink","text":"<pre><code>SourceAndSink(label: str, source: Flow, sink: Flow, prevent_simultaneous_flows: bool = True, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>class for source (output-flow) and sink (input-flow) in one commponent</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of sourceAndSink</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>source</code> <code>Flow</code> <p>output-flow of this component</p> required <code>sink</code> <code>Flow</code> <p>input-flow of this component</p> required <code>prevent_simultaneous_flows</code> <code>bool</code> <p>True: inflow and outflow are not allowed to be both non-zero at same timestep. False: inflow and outflow are working independently.</p> <code>True</code>"},{"location":"api-reference/commons/#flixOpt.commons.SourceAndSink-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.SourceAndSink.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.Storage","title":"Storage","text":"<pre><code>Storage(label: str, charging: Flow, discharging: Flow, capacity_in_flow_hours: Union[Skalar, InvestParameters], relative_minimum_charge_state: Numeric = 0, relative_maximum_charge_state: Numeric = 1, initial_charge_state: Optional[Union[Skalar, Literal['lastValueOfSim']]] = 0, minimal_final_charge_state: Optional[Skalar] = None, maximal_final_charge_state: Optional[Skalar] = None, eta_charge: Numeric = 1, eta_discharge: Numeric = 1, relative_loss_per_hour: Numeric = 0, prevent_simultaneous_charge_and_discharge: bool = True, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Klasse Storage</p> <p>constructor of storage</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>description.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>charging</code> <code>Flow</code> <p>ingoing flow.</p> required <code>discharging</code> <code>Flow</code> <p>outgoing flow.</p> required <code>capacity_in_flow_hours</code> <code>Skalar or InvestParameter</code> <p>nominal capacity of the storage</p> required <code>relative_minimum_charge_state</code> <code>float or TS</code> <p>minimum relative charge state. The default is 0.</p> <code>0</code> <code>relative_maximum_charge_state</code> <code>float or TS</code> <p>maximum relative charge state. The default is 1.</p> <code>1</code> <code>initial_charge_state</code> <code>None, float (0...1), 'lastValueOfSim',  optional</code> <p>storage charge_state at the beginning. The default is 0. float: defined charge_state at start of first timestep None: free to choose by optimizer 'lastValueOfSim': chargeState0 is equal to chargestate of last timestep (\"closed simulation\")</p> <code>0</code> <code>minimal_final_charge_state</code> <code>float or None</code> <p>minimal value of chargeState at the end of timeseries.</p> <code>None</code> <code>maximal_final_charge_state</code> <code>float or None</code> <p>maximal value of chargeState at the end of timeseries.</p> <code>None</code> <code>eta_charge</code> <code>float</code> <p>efficiency factor of charging/loading. The default is 1.</p> <code>1</code> <code>eta_discharge</code> <code>TYPE</code> <p>efficiency factor of uncharging/unloading. The default is 1.</p> <code>1</code> <code>relative_loss_per_hour</code> <code>float or optional</code> <p>loss per chargeState-Unit per hour. The default is 0.</p> <code>0</code> <code>prevent_simultaneous_charge_and_discharge</code> <code>boolean</code> <p>should simultaneously Loading and Unloading be avoided? (Attention, Performance maybe becomes worse with avoidInAndOutAtOnce=True). The default is True.</p> <code>True</code>"},{"location":"api-reference/commons/#flixOpt.commons.Storage-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.Storage.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.Transmission","title":"Transmission","text":"<pre><code>Transmission(label: str, in1: Flow, out1: Flow, in2: Optional[Flow] = None, out2: Optional[Flow] = None, relative_losses: Optional[Numeric_TS] = None, absolute_losses: Optional[Numeric_TS] = None, on_off_parameters: OnOffParameters = None, prevent_simultaneous_flows_in_both_directions: bool = True)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Initializes a Transmission component (Pipe, cable, ...) that models the flows between two sides with potential losses.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The name of the transmission component.</p> required <code>in1</code> <code>Flow</code> <p>The inflow at side A. Pass InvestmentParameters here.</p> required <code>out1</code> <code>Flow</code> <p>The outflow at side B.</p> required <code>in2</code> <code>Optional[Flow]</code> <p>The optional inflow at side B. If in1 got Investmentparameters, the size of this Flow will be equal to in1 (with no extra effects!)</p> <code>None</code> <code>out2</code> <code>Optional[Flow]</code> <p>The optional outflow at side A.</p> <code>None</code> <code>relative_losses</code> <code>Optional[Numeric_TS]</code> <p>The relative loss between inflow and outflow, e.g., 0.02 for 2% loss.</p> <code>None</code> <code>absolute_losses</code> <code>Optional[Numeric_TS]</code> <p>The absolute loss, occur only when the Flow is on. Induces the creation of the ON-Variable</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>prevent_simultaneous_flows_in_both_directions</code> <code>bool</code> <p>If True, prevents simultaneous flows in both directions.</p> <code>True</code>"},{"location":"api-reference/commons/#flixOpt.commons.Transmission-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.Transmission.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.CONFIG","title":"CONFIG","text":"<p>A configuration class that stores global configuration values as class attributes.</p>"},{"location":"api-reference/commons/#flixOpt.commons.CONFIG-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.CONFIG.load_config","title":"load_config  <code>classmethod</code>","text":"<pre><code>load_config(user_config_file: Optional[str] = None)\n</code></pre> <p>Initialize configuration using defaults or user-specified file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.CONFIG.to_dict","title":"to_dict  <code>classmethod</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the configuration class into a dictionary for JSON serialization. Handles dataclasses and simple types like str, int, etc.</p>"},{"location":"api-reference/commons/#flixOpt.commons.TimeSeriesData","title":"TimeSeriesData","text":"<pre><code>TimeSeriesData(data: Numeric, agg_group: Optional[str] = None, agg_weight: Optional[float] = None)\n</code></pre> <p>timeseries class for transmit timeseries AND special characteristics of timeseries, i.g. to define weights needed in calculation_type 'aggregated'     EXAMPLE solar:     you have several solar timeseries. These should not be overweighted     compared to the remaining timeseries (i.g. heat load, price)!     fixed_relative_profile_solar1 = TimeSeriesData(sol_array_1, type = 'solar')     fixed_relative_profile_solar2 = TimeSeriesData(sol_array_2, type = 'solar')     fixed_relative_profile_solar3 = TimeSeriesData(sol_array_3, type = 'solar')     --&gt; this 3 series of same type share one weight, i.e. internally assigned each weight = 1/3     (instead of standard weight = 1)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[int, float, ndarray]</code> <p>The timeseries data, which can be a scalar, array, or numpy array.</p> required <code>agg_group</code> <code>str</code> <p>The group this TimeSeriesData is a part of. agg_weight is split between members of a group. Default is None.</p> <code>None</code> <code>agg_weight</code> <code>float</code> <p>The weight for calculation_type 'aggregated', should be between 0 and 1. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If both agg_group and agg_weight are set, an exception is raised.</p>"},{"location":"api-reference/commons/#flixOpt.commons.TimeSeriesData-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.Effect","title":"Effect","text":"<pre><code>Effect(label: str, unit: str, description: str, meta_data: Optional[Dict] = None, is_standard: bool = False, is_objective: bool = False, specific_share_to_other_effects_operation: EffectValues = None, specific_share_to_other_effects_invest: EffectValuesInvest = None, minimum_operation: Optional[Skalar] = None, maximum_operation: Optional[Skalar] = None, minimum_invest: Optional[Skalar] = None, maximum_invest: Optional[Skalar] = None, minimum_operation_per_hour: Optional[Numeric_TS] = None, maximum_operation_per_hour: Optional[Numeric_TS] = None, minimum_total: Optional[Skalar] = None, maximum_total: Optional[Skalar] = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Effect, i.g. costs, CO2 emissions, area, ... Components, FLows, and so on can contribute to an Effect. One Effect is chosen as the Objective of the Optimization</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name</p> required <code>unit</code> <code>str</code> <p>unit of effect, i.g. \u20ac, kg_CO2, kWh_primaryEnergy</p> required <code>description</code> <code>str</code> <p>long name</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>is_standard</code> <code>boolean</code> <p>true, if Standard-Effect (for direct input of value without effect (alternatively to dict)) , else false</p> <code>False</code> <code>is_objective</code> <code>boolean</code> <p>true, if optimization target</p> <code>False</code> <code>specific_share_to_other_effects_operation</code> <code>effectType: TS, ...}, i.g. 180 \u20ac/t_CO2, input as {costs: 180</code> <p>share to other effects (only operation)</p> <code>effectType: TS</code> <code>specific_share_to_other_effects_invest</code> <code>effectType: TS, ...}, i.g. 180 \u20ac/t_CO2, input as {costs: 180</code> <p>share to other effects (only invest).</p> <code>effectType: TS</code> <code>minimum_operation</code> <code>scalar</code> <p>minimal sum (only operation) of the effect</p> <code>None</code> <code>maximum_operation</code> <code>scalar</code> <p>maximal sum (nur operation) of the effect.</p> <code>None</code> <code>minimum_operation_per_hour</code> <code>scalar or TS</code> <p>maximum value per hour (only operation) of effect (=sum of all effect-shares) for each timestep!</p> <code>None</code> <code>maximum_operation_per_hour</code> <code>scalar or TS</code> <p>minimum value per hour (only operation) of effect (=sum of all effect-shares) for each timestep!</p> <code>None</code> <code>minimum_invest</code> <code>scalar</code> <p>minimal sum (only invest) of the effect</p> <code>None</code> <code>maximum_invest</code> <code>scalar</code> <p>maximal sum (only invest) of the effect</p> <code>None</code> <code>minimum_total</code> <code>sclalar</code> <p>min sum of effect (invest+operation).</p> <code>None</code> <code>maximum_total</code> <code>scalar</code> <p>max sum of effect (invest+operation).</p> <code>None</code> <code>**kwargs</code> <code>TYPE</code> <p>DESCRIPTION.</p> required <p>Returns:</p> Type Description <code>None.</code>"},{"location":"api-reference/commons/#flixOpt.commons.Effect-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.Effect.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixOpt.commons.Effect.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.Bus","title":"Bus","text":"<pre><code>Bus(label: str, excess_penalty_per_flow_hour: Optional[Numeric_TS] = 100000.0, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>realizing balance of all linked flows (penalty flow is excess can be activated)</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>excess_penalty_per_flow_hour</code> <code>(none or scalar, array or TimeSeriesData)</code> <p>excess costs / penalty costs (bus balance compensation) (none/ 0 -&gt; no penalty). The default is 1e5. (Take care: if you use a timeseries (no scalar), timeseries is aggregated if calculation_type = aggregated!)</p> <code>100000.0</code>"},{"location":"api-reference/commons/#flixOpt.commons.Bus-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.Bus.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixOpt.commons.Bus.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.Flow","title":"Flow","text":"<pre><code>Flow(label: str, bus: Bus, size: Union[Skalar, InvestParameters] = None, fixed_relative_profile: Optional[Numeric_TS] = None, relative_minimum: Numeric_TS = 0, relative_maximum: Numeric_TS = 1, effects_per_flow_hour: EffectValues = None, on_off_parameters: Optional[OnOffParameters] = None, flow_hours_total_max: Optional[Skalar] = None, flow_hours_total_min: Optional[Skalar] = None, load_factor_min: Optional[Skalar] = None, load_factor_max: Optional[Skalar] = None, previous_flow_rate: Optional[Numeric] = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>flows are inputs and outputs of components</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of flow</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>bus</code> <code>Bus</code> <p>bus to which flow is linked</p> required <code>size</code> <code>(scalar, InvestmentParameters)</code> <p>size of the flow. If InvestmentParameters is used, size is optimized. If size is None, a default value is used.</p> <code>None</code> <code>relative_minimum</code> <code>(scalar, array, TimeSeriesData)</code> <p>min value is relative_minimum multiplied by size</p> <code>0</code> <code>relative_maximum</code> <code>(scalar, array, TimeSeriesData)</code> <p>max value is relative_maximum multiplied by size. If size = max then relative_maximum=1</p> <code>1</code> <code>load_factor_min</code> <code>scalar</code> <p>minimal load factor  general: avg Flow per nominalVal/investSize (e.g. boiler, kW/kWh=h; solarthermal: kW/m\u00b2;  def: :math:<code>load\\_factor:= sumFlowHours/ (nominal\\_val \\cdot \\Delta t_{tot})</code></p> <code>None</code> <code>load_factor_max</code> <code>scalar</code> <p>maximal load factor (see minimal load factor)</p> <code>None</code> <code>effects_per_flow_hour</code> <code>(scalar, array, TimeSeriesData)</code> <p>operational costs, costs per flow-\"work\"</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters</code> <p>If present, flow can be \"off\", i.e. be zero (only relevant if relative_minimum &gt; 0) Therefore a binary var \"on\" is used. Further, several other restrictions and effects can be modeled through this On/Off State (See OnOffParameters)</p> <code>None</code> <code>flow_hours_total_max</code> <code>TYPE</code> <p>maximum flow-hours (\"flow-work\") (if size is not const, maybe load_factor_max fits better for you!)</p> <code>None</code> <code>flow_hours_total_min</code> <code>TYPE</code> <p>minimum flow-hours (\"flow-work\") (if size is not const, maybe load_factor_min fits better for you!)</p> <code>None</code> <code>fixed_relative_profile</code> <code>(scalar, array, TimeSeriesData)</code> <p>fixed relative values for flow (if given). val(t) := fixed_relative_profile(t) * size(t) With this value, the flow_rate is no opt-variable anymore; (relative_minimum u. relative_maximum are making sense anymore) used for fixed load profiles, i.g. heat demand, wind-power, solarthermal If the load-profile is just an upper limit, use relative_maximum instead.</p> <code>None</code> <code>previous_flow_rate</code> <code>(scalar, array)</code> <p>previous flow rate of the component.</p> <code>None</code>"},{"location":"api-reference/commons/#flixOpt.commons.Flow-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.Flow.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.FlowSystem","title":"FlowSystem","text":"<pre><code>FlowSystem(time_series: ndarray[datetime64], last_time_step_hours: Optional[Union[int, float]] = None, previous_dt_in_hours: Optional[Union[int, float, ndarray]] = None)\n</code></pre> <p>A FlowSystem organizes the high level Elements (Components &amp; Effects).</p> <p>Parameters:</p> Name Type Description Default <code>time_series</code> <code>np.ndarray of datetime64</code> <p>timeseries of the data. Must be in datetime64 format. Don't use precisions below 'us'. !np.datetime64[ns]!</p> required <code>last_time_step_hours</code> <code>Optional[Union[int, float]]</code> <p>The duration of last time step. Storages needs this time-duration for calculation of charge state after last time step. If None, then last time increment of time_series is used.</p> <code>None</code> <code>previous_dt_in_hours</code> <code>Union[int, float, ndarray]</code> <p>The duration of previous time steps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code>"},{"location":"api-reference/commons/#flixOpt.commons.FlowSystem-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.FlowSystem.add_elements","title":"add_elements","text":"<pre><code>add_elements(*args: Element) -&gt; None\n</code></pre> <p>add all modeling elements, like storages, boilers, heatpumps, buses, ...</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>childs of  Element like Boiler, HeatPump, Bus,...</code> <p>modeling Elements</p> <code>()</code>"},{"location":"api-reference/commons/#flixOpt.commons.FlowSystem.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the flow system to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.FlowSystem.visualize_network","title":"visualize_network","text":"<pre><code>visualize_network(path: Union[bool, str, Path] = 'flow_system.html', controls: Union[bool, List[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]] = True, show: bool = True) -&gt; Optional[pyvis.network.Network]\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, saving it as an interactive HTML file.</p> <p>Parameters: - path (Union[bool, str, pathlib.Path], default='flow_system.html'):   Path to save the HTML visualization.     - <code>False</code>: Visualization is created but not saved.     - <code>str</code> or <code>Path</code>: Specifies file path (default: 'flow_system.html').</p> <ul> <li> <p>controls (Union[bool, List[str]], default=True):   UI controls to add to the visualization.</p> <ul> <li><code>True</code>: Enables all available controls.</li> <li><code>List</code>: Specify controls, e.g., ['nodes', 'layout'].</li> <li>Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'.</li> </ul> </li> <li> <p>show (bool, default=True):   Whether to open the visualization in the web browser.</p> </li> </ul> <p>Returns: - Optional[pyvis.network.Network]: The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Usage: - Visualize and open the network with default options:</p> <p>self.visualize_network()</p> <ul> <li> <p>Save the visualization without opening:</p> <p>self.visualize_network(show=False)</p> </li> <li> <p>Visualize with custom controls and path:</p> <p>self.visualize_network(path='output/custom_network.html', controls=['nodes', 'layout'])</p> </li> </ul> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/commons/#flixOpt.commons.FlowSystem.get_time_data_from_indices","title":"get_time_data_from_indices","text":"<pre><code>get_time_data_from_indices(time_indices: Optional[Union[List[int], range]] = None) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.float64]\n</code></pre> <p>Computes time series data based on the provided time indices.</p> <p>Args:     time_indices: A list of indices or a range object indicating which time steps to extract.                   If None, the entire time series is used.</p> <p>Returns:     A tuple containing:     - Extracted time series     - Time series with the \"end time\" appended     - Differences between consecutive timestamps in hours     - Total time in hours</p>"},{"location":"api-reference/commons/#flixOpt.commons.InvestParameters","title":"InvestParameters","text":"<pre><code>InvestParameters(fixed_size: Optional[Union[int, float]] = None, minimum_size: Union[int, float] = 0, maximum_size: Optional[Union[int, float]] = None, optional: bool = True, fix_effects: Union[Dict, int, float] = None, specific_effects: Union[Dict, int, float] = None, effects_in_segments: Optional[Tuple[List[Tuple[Skalar, Skalar]], Dict[Effect, List[Tuple[Skalar, Skalar]]]]] = None, divest_effects: Union[Dict, int, float] = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>collects arguments for invest-stuff</p> <p>Parameters:</p> Name Type Description Default <code>fix_effects</code> <code>None or scalar</code> <p>Fixed investment costs if invested. (Attention: Annualize costs to chosen period!)</p> <code>None</code> <code>divest_effects</code> <code>None or scalar</code> <p>Fixed divestment costs (if not invested, e.g., demolition costs or contractual penalty).</p> <code>None</code> <code>fixed_size</code> <code>(int, float)</code> <p>Determines if the investment size is fixed.</p> <code>None</code> <code>optional</code> <code>bool</code> <p>If True, investment is not forced.</p> <code>True</code> <code>specific_effects</code> <code>scalar or Dict[Effect: Union[int, float, np.ndarray]</code> <p>Specific costs, e.g., in \u20ac/kW_nominal or \u20ac/m\u00b2_nominal. Example: {costs: 3, CO2: 0.3} with costs and CO2 representing an Object of class Effect (Attention: Annualize costs to chosen period!)</p> <code>None</code> <code>effects_in_segments</code> <code>list or List[ List[Union[int,float]], Dict[cEffecType: Union[List[Union[int,float]]</code> <p>Linear relation in segments [invest_segments, cost_segments]. Example 1:     [           [5, 25, 25, 100],       # size in kW      {costs:    [50,250,250,800],       # \u20ac       PE:       [5, 25, 25, 100]        # kWh_PrimaryEnergy       }     ] Example 2 (if only standard-effect):     [   [5, 25, 25, 100],  # kW # size in kW         [50,250,250,800]        # value for standart effect, typically \u20ac      ]  # \u20ac (Attention: Annualize costs to chosen period!) (Args 'specific_effects' and 'fix_effects' can be used in parallel to InvestsizeSegments)</p> <code>None</code> <code>minimum_size</code> <code>scalar</code> <p>Min nominal value (only if: size_is_fixed = False).</p> <code>0</code> <code>maximum_size</code> <code>(scalar, Optional)</code> <p>Max nominal value (only if: size_is_fixed = False).</p> <code>None</code>"},{"location":"api-reference/commons/#flixOpt.commons.InvestParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.InvestParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixOpt.commons.InvestParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons.OnOffParameters","title":"OnOffParameters","text":"<pre><code>OnOffParameters(effects_per_switch_on: Union[Dict, Numeric] = None, effects_per_running_hour: Union[Dict, Numeric] = None, on_hours_total_min: Optional[int] = None, on_hours_total_max: Optional[int] = None, consecutive_on_hours_min: Optional[Numeric] = None, consecutive_on_hours_max: Optional[Numeric] = None, consecutive_off_hours_min: Optional[Numeric] = None, consecutive_off_hours_max: Optional[Numeric] = None, switch_on_total_max: Optional[int] = None, force_switch_on: bool = False)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>on_off_parameters class for modeling on and off state of an Element. If no parameters are given, the default is to create a binary variable for the on state without further constraints or effects and a variable for the total on hours.</p> <p>Parameters:</p> Name Type Description Default <code>effects_per_switch_on</code> <code>(scalar, array, TimeSeriesData)</code> <p>cost of one switch from off (var_on=0) to on (var_on=1), unit i.g. in Euro</p> <code>None</code> <code>effects_per_running_hour</code> <code>scalar or TS</code> <p>costs for operating, i.g. in \u20ac per hour</p> <code>None</code> <code>on_hours_total_min</code> <code>scalar</code> <p>min. overall sum of operating hours.</p> <code>None</code> <code>on_hours_total_max</code> <code>scalar</code> <p>max. overall sum of operating hours.</p> <code>None</code> <code>consecutive_on_hours_min</code> <code>scalar</code> <p>min sum of operating hours in one piece (last on-time period of timeseries is not checked and can be shorter)</p> <code>None</code> <code>consecutive_on_hours_max</code> <code>scalar</code> <p>max sum of operating hours in one piece</p> <code>None</code> <code>consecutive_off_hours_min</code> <code>scalar</code> <p>min sum of non-operating hours in one piece (last off-time period of timeseries is not checked and can be shorter)</p> <code>None</code> <code>consecutive_off_hours_max</code> <code>scalar</code> <p>max sum of non-operating hours in one piece</p> <code>None</code> <code>switch_on_total_max</code> <code>integer</code> <p>max nr of switchOn operations</p> <code>None</code> <code>force_switch_on</code> <code>bool</code> <p>force creation of switch on variable, even if there is no switch_on_total_max</p> <code>False</code>"},{"location":"api-reference/commons/#flixOpt.commons.OnOffParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixOpt.commons.OnOffParameters.use_off","title":"use_off  <code>property</code>","text":"<pre><code>use_off: bool\n</code></pre> <p>Determines wether the OFF Variable is needed or not</p>"},{"location":"api-reference/commons/#flixOpt.commons.OnOffParameters.use_consecutive_on_hours","title":"use_consecutive_on_hours  <code>property</code>","text":"<pre><code>use_consecutive_on_hours: bool\n</code></pre> <p>Determines wether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/commons/#flixOpt.commons.OnOffParameters.use_consecutive_off_hours","title":"use_consecutive_off_hours  <code>property</code>","text":"<pre><code>use_consecutive_off_hours: bool\n</code></pre> <p>Determines wether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/commons/#flixOpt.commons.OnOffParameters.use_switch_on","title":"use_switch_on  <code>property</code>","text":"<pre><code>use_switch_on: bool\n</code></pre> <p>Determines wether a Variable for SWITCH-ON is needed or not</p>"},{"location":"api-reference/commons/#flixOpt.commons.OnOffParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.OnOffParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixOpt.commons.OnOffParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/commons/#flixOpt.commons-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixOpt.commons.create_datetime_array","title":"create_datetime_array","text":"<pre><code>create_datetime_array(start: str, steps: Optional[int] = None, freq: str = '1h', end: Optional[str] = None) -&gt; np.ndarray[np.datetime64]\n</code></pre> <p>Create a NumPy array with datetime64 values.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>Start date in 'YYYY-MM-DD' format or a full timestamp (e.g., 'YYYY-MM-DD HH:MM').</p> required <code>steps</code> <code>int</code> <p>Number of steps in the datetime array. If <code>end</code> is provided, <code>steps</code> is ignored.</p> <code>None</code> <code>freq</code> <code>str</code> <p>Frequency for the datetime64 array. Supports flexible intervals: - 'Y', 'M', 'W', 'D', 'h', 'm', 's' (e.g., '1h', '15m', '2h'). Defaults to 'h' (hourly).</p> <code>'1h'</code> <code>end</code> <code>str</code> <p>End date in 'YYYY-MM-DD' format or a full timestamp (e.g., 'YYYY-MM-DD HH:MM'). If provided, the function generates an array from <code>start</code> to <code>end</code> using <code>freq</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>NumPy array of datetime64 values.</p> <p>Examples:</p> <p>Create an array with 15-minute intervals:</p> <pre><code>&gt;&gt;&gt; create_datetime_array('2023-01-01', steps=5, freq='15m')\narray(['2023-01-01T00:00', '2023-01-01T00:15', '2023-01-01T00:30', ...], dtype='datetime64[m]')\n</code></pre> <p>Create 2-hour intervals:</p> <pre><code>&gt;&gt;&gt; create_datetime_array('2023-01-01T00', steps=4, freq='2h')\narray(['2023-01-01T00', '2023-01-01T02', '2023-01-01T04', ...], dtype='datetime64[h]')\n</code></pre> <p>Generate minute intervals until a specified end time:</p> <pre><code>&gt;&gt;&gt; create_datetime_array('2023-01-01T00:00', end='2023-01-01T01:00', freq='m')\narray(['2023-01-01T00:00', '2023-01-01T00:01', ..., '2023-01-01T00:59'], dtype='datetime64[m]')\n</code></pre>"},{"location":"api-reference/components/","title":"components","text":""},{"location":"api-reference/components/#flixOpt.components","title":"flixOpt.components","text":"<p>This module contains the basic components of the flixOpt framework.</p>"},{"location":"api-reference/components/#flixOpt.components-classes","title":"Classes","text":""},{"location":"api-reference/components/#flixOpt.components.LinearConverter","title":"LinearConverter","text":"<pre><code>LinearConverter(label: str, inputs: List[Flow], outputs: List[Flow], on_off_parameters: OnOffParameters = None, conversion_factors: List[Dict[Flow, Numeric_TS]] = None, segmented_conversion_factors: Dict[Flow, List[Tuple[Numeric_TS, Numeric_TS]]] = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Converts one FLow into another via linear conversion factors</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>inputs</code> <code>input flows.</code> required <code>outputs</code> <code>output flows.</code> required <code>on_off_parameters</code> <code>OnOffParameters</code> <code>None</code> <code>conversion_factors</code> <code>linear relation between flows.</code> <p>Either 'conversion_factors' or 'segmented_conversion_factors' can be used! example heat pump:</p> <code>None</code> <code>segmented_conversion_factors</code> <code> Segmented linear relation between flows.</code> <p>Each Flow gets a List of Segments assigned. If FLows need to be 0 (or Off), include a \"Zero-Segment\" \"(0, 0)\", or use on_off_parameters Either 'segmented_conversion_factors' or 'conversion_factors' can be used! --&gt; \"gaps\" can be expressed by a segment not starting at the end of the prior segment : [(1,3), (4,5)] --&gt; \"points\" can expressed as segment with same begin and end : [(3,3), (4,4)]</p> <code>None</code>"},{"location":"api-reference/components/#flixOpt.components.LinearConverter-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixOpt.components.LinearConverter.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/components/#flixOpt.components.Storage","title":"Storage","text":"<pre><code>Storage(label: str, charging: Flow, discharging: Flow, capacity_in_flow_hours: Union[Skalar, InvestParameters], relative_minimum_charge_state: Numeric = 0, relative_maximum_charge_state: Numeric = 1, initial_charge_state: Optional[Union[Skalar, Literal['lastValueOfSim']]] = 0, minimal_final_charge_state: Optional[Skalar] = None, maximal_final_charge_state: Optional[Skalar] = None, eta_charge: Numeric = 1, eta_discharge: Numeric = 1, relative_loss_per_hour: Numeric = 0, prevent_simultaneous_charge_and_discharge: bool = True, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Klasse Storage</p> <p>constructor of storage</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>description.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>charging</code> <code>Flow</code> <p>ingoing flow.</p> required <code>discharging</code> <code>Flow</code> <p>outgoing flow.</p> required <code>capacity_in_flow_hours</code> <code>Skalar or InvestParameter</code> <p>nominal capacity of the storage</p> required <code>relative_minimum_charge_state</code> <code>float or TS</code> <p>minimum relative charge state. The default is 0.</p> <code>0</code> <code>relative_maximum_charge_state</code> <code>float or TS</code> <p>maximum relative charge state. The default is 1.</p> <code>1</code> <code>initial_charge_state</code> <code>None, float (0...1), 'lastValueOfSim',  optional</code> <p>storage charge_state at the beginning. The default is 0. float: defined charge_state at start of first timestep None: free to choose by optimizer 'lastValueOfSim': chargeState0 is equal to chargestate of last timestep (\"closed simulation\")</p> <code>0</code> <code>minimal_final_charge_state</code> <code>float or None</code> <p>minimal value of chargeState at the end of timeseries.</p> <code>None</code> <code>maximal_final_charge_state</code> <code>float or None</code> <p>maximal value of chargeState at the end of timeseries.</p> <code>None</code> <code>eta_charge</code> <code>float</code> <p>efficiency factor of charging/loading. The default is 1.</p> <code>1</code> <code>eta_discharge</code> <code>TYPE</code> <p>efficiency factor of uncharging/unloading. The default is 1.</p> <code>1</code> <code>relative_loss_per_hour</code> <code>float or optional</code> <p>loss per chargeState-Unit per hour. The default is 0.</p> <code>0</code> <code>prevent_simultaneous_charge_and_discharge</code> <code>boolean</code> <p>should simultaneously Loading and Unloading be avoided? (Attention, Performance maybe becomes worse with avoidInAndOutAtOnce=True). The default is True.</p> <code>True</code>"},{"location":"api-reference/components/#flixOpt.components.Storage-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixOpt.components.Storage.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/components/#flixOpt.components.Transmission","title":"Transmission","text":"<pre><code>Transmission(label: str, in1: Flow, out1: Flow, in2: Optional[Flow] = None, out2: Optional[Flow] = None, relative_losses: Optional[Numeric_TS] = None, absolute_losses: Optional[Numeric_TS] = None, on_off_parameters: OnOffParameters = None, prevent_simultaneous_flows_in_both_directions: bool = True)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Initializes a Transmission component (Pipe, cable, ...) that models the flows between two sides with potential losses.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The name of the transmission component.</p> required <code>in1</code> <code>Flow</code> <p>The inflow at side A. Pass InvestmentParameters here.</p> required <code>out1</code> <code>Flow</code> <p>The outflow at side B.</p> required <code>in2</code> <code>Optional[Flow]</code> <p>The optional inflow at side B. If in1 got Investmentparameters, the size of this Flow will be equal to in1 (with no extra effects!)</p> <code>None</code> <code>out2</code> <code>Optional[Flow]</code> <p>The optional outflow at side A.</p> <code>None</code> <code>relative_losses</code> <code>Optional[Numeric_TS]</code> <p>The relative loss between inflow and outflow, e.g., 0.02 for 2% loss.</p> <code>None</code> <code>absolute_losses</code> <code>Optional[Numeric_TS]</code> <p>The absolute loss, occur only when the Flow is on. Induces the creation of the ON-Variable</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>prevent_simultaneous_flows_in_both_directions</code> <code>bool</code> <p>If True, prevents simultaneous flows in both directions.</p> <code>True</code>"},{"location":"api-reference/components/#flixOpt.components.Transmission-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixOpt.components.Transmission.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/components/#flixOpt.components.TransmissionModel","title":"TransmissionModel","text":"<pre><code>TransmissionModel(element: Transmission)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p>"},{"location":"api-reference/components/#flixOpt.components.TransmissionModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixOpt.components.TransmissionModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling(system_model: SystemModel)\n</code></pre> <p>Initiates all FlowModels</p>"},{"location":"api-reference/components/#flixOpt.components.TransmissionModel.create_transmission_equation","title":"create_transmission_equation","text":"<pre><code>create_transmission_equation(name: str, in_flow: Flow, out_flow: Flow) -&gt; Equation\n</code></pre> <p>Creates an Equation for the Transmission efficiency and adds it to the model</p>"},{"location":"api-reference/components/#flixOpt.components.StorageModel","title":"StorageModel","text":"<pre><code>StorageModel(element: Storage)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p> <p>Model of Storage</p>"},{"location":"api-reference/components/#flixOpt.components.SourceAndSink","title":"SourceAndSink","text":"<pre><code>SourceAndSink(label: str, source: Flow, sink: Flow, prevent_simultaneous_flows: bool = True, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>class for source (output-flow) and sink (input-flow) in one commponent</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of sourceAndSink</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>source</code> <code>Flow</code> <p>output-flow of this component</p> required <code>sink</code> <code>Flow</code> <p>input-flow of this component</p> required <code>prevent_simultaneous_flows</code> <code>bool</code> <p>True: inflow and outflow are not allowed to be both non-zero at same timestep. False: inflow and outflow are working independently.</p> <code>True</code>"},{"location":"api-reference/components/#flixOpt.components.SourceAndSink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixOpt.components.SourceAndSink.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/components/#flixOpt.components.Source","title":"Source","text":"<pre><code>Source(label: str, source: Flow, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of source</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>source</code> <code>Flow</code> <p>output-flow of source</p> required"},{"location":"api-reference/components/#flixOpt.components.Source-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixOpt.components.Source.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/components/#flixOpt.components.Sink","title":"Sink","text":"<pre><code>Sink(label: str, sink: Flow, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>constructor of sink</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of sink.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>sink</code> <code>Flow</code> <p>input-flow of sink</p> required"},{"location":"api-reference/components/#flixOpt.components.Sink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixOpt.components.Sink.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/components/#flixOpt.components-functions","title":"Functions","text":""},{"location":"api-reference/config/","title":"config","text":""},{"location":"api-reference/config/#flixOpt.config","title":"flixOpt.config","text":""},{"location":"api-reference/config/#flixOpt.config-classes","title":"Classes","text":""},{"location":"api-reference/config/#flixOpt.config.CONFIG","title":"CONFIG","text":"<p>A configuration class that stores global configuration values as class attributes.</p>"},{"location":"api-reference/config/#flixOpt.config.CONFIG-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixOpt.config.CONFIG.load_config","title":"load_config  <code>classmethod</code>","text":"<pre><code>load_config(user_config_file: Optional[str] = None)\n</code></pre> <p>Initialize configuration using defaults or user-specified file.</p>"},{"location":"api-reference/config/#flixOpt.config.CONFIG.to_dict","title":"to_dict  <code>classmethod</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the configuration class into a dictionary for JSON serialization. Handles dataclasses and simple types like str, int, etc.</p>"},{"location":"api-reference/config/#flixOpt.config-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixOpt.config.merge_configs","title":"merge_configs","text":"<pre><code>merge_configs(defaults: dict, overrides: dict) -&gt; dict\n</code></pre> <p>Merge the default configuration with user-provided overrides.</p> <p>:param defaults: Default configuration dictionary. :param overrides: User configuration dictionary. :return: Merged configuration dictionary.</p>"},{"location":"api-reference/config/#flixOpt.config.dataclass_from_dict_with_validation","title":"dataclass_from_dict_with_validation","text":"<pre><code>dataclass_from_dict_with_validation(cls, data: dict)\n</code></pre> <p>Recursively initialize a dataclass from a dictionary.</p>"},{"location":"api-reference/config/#flixOpt.config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(default_level: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'] = 'INFO', log_file: Optional[str] = 'flixOpt.log', use_rich_handler: bool = False)\n</code></pre> <p>Setup logging configuration</p>"},{"location":"api-reference/core/","title":"core","text":""},{"location":"api-reference/core/#flixOpt.core","title":"flixOpt.core","text":"<p>This module contains the core functionality of the flixOpt framework. It provides Datatypes, logging functionality, and some functions to transform data structures.</p>"},{"location":"api-reference/core/#flixOpt.core-classes","title":"Classes","text":""},{"location":"api-reference/core/#flixOpt.core.TimeSeriesData","title":"TimeSeriesData","text":"<pre><code>TimeSeriesData(data: Numeric, agg_group: Optional[str] = None, agg_weight: Optional[float] = None)\n</code></pre> <p>timeseries class for transmit timeseries AND special characteristics of timeseries, i.g. to define weights needed in calculation_type 'aggregated'     EXAMPLE solar:     you have several solar timeseries. These should not be overweighted     compared to the remaining timeseries (i.g. heat load, price)!     fixed_relative_profile_solar1 = TimeSeriesData(sol_array_1, type = 'solar')     fixed_relative_profile_solar2 = TimeSeriesData(sol_array_2, type = 'solar')     fixed_relative_profile_solar3 = TimeSeriesData(sol_array_3, type = 'solar')     --&gt; this 3 series of same type share one weight, i.e. internally assigned each weight = 1/3     (instead of standard weight = 1)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[int, float, ndarray]</code> <p>The timeseries data, which can be a scalar, array, or numpy array.</p> required <code>agg_group</code> <code>str</code> <p>The group this TimeSeriesData is a part of. agg_weight is split between members of a group. Default is None.</p> <code>None</code> <code>agg_weight</code> <code>float</code> <p>The weight for calculation_type 'aggregated', should be between 0 and 1. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If both agg_group and agg_weight are set, an exception is raised.</p>"},{"location":"api-reference/core/#flixOpt.core.TimeSeriesData-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixOpt.core.TimeSeries","title":"TimeSeries","text":"<pre><code>TimeSeries(label: str, data: Optional[Numeric_TS])\n</code></pre> <p>Class for data that applies to time series, stored as vector (np.ndarray) or scalar.</p> <p>This class represents a vector or scalar value that makes the handling of time series easier. It supports various operations such as activation of specific time indices, setting explicit active data, and aggregation weight management.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>The label for the time series.</p> <code>data</code> <code>Optional[Numeric]</code> <p>The actual data for the time series. Can be None.</p> <code>aggregated_data</code> <code>Optional[Numeric]</code> <p>aggregated_data to use instead of data if provided.</p> <code>active_indices</code> <code>Optional[ndarray]</code> <p>Indices of the time steps to activate.</p> <code>aggregation_weight</code> <code>float</code> <p>Weight for aggregation method, between 0 and 1, normally 1.</p> <code>aggregation_group</code> <code>str</code> <p>Group for calculating the aggregation weigth for aggregation method.</p>"},{"location":"api-reference/core/#flixOpt.core.TimeSeries-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixOpt.core.TimeSeries.make_scalar_if_possible","title":"make_scalar_if_possible  <code>staticmethod</code>","text":"<pre><code>make_scalar_if_possible(data: Optional[Numeric]) -&gt; Optional[Numeric]\n</code></pre> <p>Convert an array to a scalar if all values are equal, or return the array as-is. Can Return None if the passed data is None</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>(Numeric, None)</code> <p>The data to process.</p> required <p>Returns:</p> Type Description <code>Numeric</code> <p>A scalar if all values in the array are equal, otherwise the array itself. None, if the passed value is None</p>"},{"location":"api-reference/effects/","title":"effects","text":""},{"location":"api-reference/effects/#flixOpt.effects","title":"flixOpt.effects","text":"<p>This module contains the effects of the flixOpt framework. Furthermore, it contains the EffectCollection, which is used to collect all effects of a system. Different Datatypes are used to represent the effects with assigned values by the user, which are then transformed into the internal data structure.</p>"},{"location":"api-reference/effects/#flixOpt.effects-classes","title":"Classes","text":""},{"location":"api-reference/effects/#flixOpt.effects.Effect","title":"Effect","text":"<pre><code>Effect(label: str, unit: str, description: str, meta_data: Optional[Dict] = None, is_standard: bool = False, is_objective: bool = False, specific_share_to_other_effects_operation: EffectValues = None, specific_share_to_other_effects_invest: EffectValuesInvest = None, minimum_operation: Optional[Skalar] = None, maximum_operation: Optional[Skalar] = None, minimum_invest: Optional[Skalar] = None, maximum_invest: Optional[Skalar] = None, minimum_operation_per_hour: Optional[Numeric_TS] = None, maximum_operation_per_hour: Optional[Numeric_TS] = None, minimum_total: Optional[Skalar] = None, maximum_total: Optional[Skalar] = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Effect, i.g. costs, CO2 emissions, area, ... Components, FLows, and so on can contribute to an Effect. One Effect is chosen as the Objective of the Optimization</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name</p> required <code>unit</code> <code>str</code> <p>unit of effect, i.g. \u20ac, kg_CO2, kWh_primaryEnergy</p> required <code>description</code> <code>str</code> <p>long name</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>is_standard</code> <code>boolean</code> <p>true, if Standard-Effect (for direct input of value without effect (alternatively to dict)) , else false</p> <code>False</code> <code>is_objective</code> <code>boolean</code> <p>true, if optimization target</p> <code>False</code> <code>specific_share_to_other_effects_operation</code> <code>effectType: TS, ...}, i.g. 180 \u20ac/t_CO2, input as {costs: 180</code> <p>share to other effects (only operation)</p> <code>effectType: TS</code> <code>specific_share_to_other_effects_invest</code> <code>effectType: TS, ...}, i.g. 180 \u20ac/t_CO2, input as {costs: 180</code> <p>share to other effects (only invest).</p> <code>effectType: TS</code> <code>minimum_operation</code> <code>scalar</code> <p>minimal sum (only operation) of the effect</p> <code>None</code> <code>maximum_operation</code> <code>scalar</code> <p>maximal sum (nur operation) of the effect.</p> <code>None</code> <code>minimum_operation_per_hour</code> <code>scalar or TS</code> <p>maximum value per hour (only operation) of effect (=sum of all effect-shares) for each timestep!</p> <code>None</code> <code>maximum_operation_per_hour</code> <code>scalar or TS</code> <p>minimum value per hour (only operation) of effect (=sum of all effect-shares) for each timestep!</p> <code>None</code> <code>minimum_invest</code> <code>scalar</code> <p>minimal sum (only invest) of the effect</p> <code>None</code> <code>maximum_invest</code> <code>scalar</code> <p>maximal sum (only invest) of the effect</p> <code>None</code> <code>minimum_total</code> <code>sclalar</code> <p>min sum of effect (invest+operation).</p> <code>None</code> <code>maximum_total</code> <code>scalar</code> <p>max sum of effect (invest+operation).</p> <code>None</code> <code>**kwargs</code> <code>TYPE</code> <p>DESCRIPTION.</p> required <p>Returns:</p> Type Description <code>None.</code>"},{"location":"api-reference/effects/#flixOpt.effects.Effect-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixOpt.effects.Effect.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/effects/#flixOpt.effects.Effect.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/effects/#flixOpt.effects.EffectCollection","title":"EffectCollection","text":"<pre><code>EffectCollection(label: str)\n</code></pre> <p>Handling all Effects</p>"},{"location":"api-reference/effects/#flixOpt.effects-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixOpt.effects.nested_values_to_time_series","title":"nested_values_to_time_series","text":"<pre><code>nested_values_to_time_series(nested_values: Dict[Element, Numeric_TS], label_suffix: str, parent_element: Element) -&gt; ElementTimeSeries\n</code></pre> <p>Creates TimeSeries from nested values, which are a Dict of Elements to values. The resulting label of the TimeSeries is the label of the parent_element, followed by the label of the element in the nested_values and the label_suffix.</p>"},{"location":"api-reference/effects/#flixOpt.effects.effect_values_to_time_series","title":"effect_values_to_time_series","text":"<pre><code>effect_values_to_time_series(label_suffix: str, nested_values: EffectValues, parent_element: Element) -&gt; Optional[EffectTimeSeries]\n</code></pre> <p>Creates TimeSeries from EffectValues. The resulting label of the TimeSeries is the label of the parent_element, followed by the label of the Effect in the nested_values and the label_suffix. If the key in the EffectValues is None, the alias 'Standart_Effect' is used</p>"},{"location":"api-reference/effects/#flixOpt.effects.as_effect_dict","title":"as_effect_dict","text":"<pre><code>as_effect_dict(effect_values: EffectValues) -&gt; Optional[EffectDict]\n</code></pre> <p>Converts effect values into a dictionary. If a scalar is provided, it is associated with a default effect type.</p> <p>Examples:</p> <p>costs = 20                        -&gt; {None: 20} costs = None                      -&gt; None costs = {effect1: 20, effect2: 0.3} -&gt; {effect1: 20, effect2: 0.3}</p> <p>Parameters:</p> Name Type Description Default <code>effect_values</code> <code>None, int, float, TimeSeries, or dict</code> <p>The effect values to convert, either a scalar, TimeSeries, or a dictionary.</p> required <p>Returns:</p> Type Description <code>dict or None</code> <p>A dictionary with None or Effect as the key, or None if input is None.</p>"},{"location":"api-reference/elements/","title":"elements","text":""},{"location":"api-reference/elements/#flixOpt.elements","title":"flixOpt.elements","text":"<p>This module contains the basic elements of the flixOpt framework.</p>"},{"location":"api-reference/elements/#flixOpt.elements-classes","title":"Classes","text":""},{"location":"api-reference/elements/#flixOpt.elements.Component","title":"Component","text":"<pre><code>Component(label: str, inputs: Optional[List[Flow]] = None, outputs: Optional[List[Flow]] = None, on_off_parameters: Optional[OnOffParameters] = None, prevent_simultaneous_flows: Optional[List[Flow]] = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>basic component class for all components</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>inputs</code> <code>input flows.</code> <code>None</code> <code>outputs</code> <code>output flows.</code> <code>None</code> <code>on_off_parameters</code> <code>Optional[OnOffParameters]</code> <p>Component is On/Off, if all connected Flows are On/Off. Induces On-Variable in all FLows! See class OnOffParameters.</p> <code>None</code> <code>prevent_simultaneous_flows</code> <code>Optional[List[Flow]]</code> <p>Induces On-Variable in all FLows!</p> <code>None</code>"},{"location":"api-reference/elements/#flixOpt.elements.Component-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixOpt.elements.Component.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/elements/#flixOpt.elements.Bus","title":"Bus","text":"<pre><code>Bus(label: str, excess_penalty_per_flow_hour: Optional[Numeric_TS] = 100000.0, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>realizing balance of all linked flows (penalty flow is excess can be activated)</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>excess_penalty_per_flow_hour</code> <code>(none or scalar, array or TimeSeriesData)</code> <p>excess costs / penalty costs (bus balance compensation) (none/ 0 -&gt; no penalty). The default is 1e5. (Take care: if you use a timeseries (no scalar), timeseries is aggregated if calculation_type = aggregated!)</p> <code>100000.0</code>"},{"location":"api-reference/elements/#flixOpt.elements.Bus-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixOpt.elements.Bus.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/elements/#flixOpt.elements.Bus.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/elements/#flixOpt.elements.Flow","title":"Flow","text":"<pre><code>Flow(label: str, bus: Bus, size: Union[Skalar, InvestParameters] = None, fixed_relative_profile: Optional[Numeric_TS] = None, relative_minimum: Numeric_TS = 0, relative_maximum: Numeric_TS = 1, effects_per_flow_hour: EffectValues = None, on_off_parameters: Optional[OnOffParameters] = None, flow_hours_total_max: Optional[Skalar] = None, flow_hours_total_min: Optional[Skalar] = None, load_factor_min: Optional[Skalar] = None, load_factor_max: Optional[Skalar] = None, previous_flow_rate: Optional[Numeric] = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>flows are inputs and outputs of components</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of flow</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>bus</code> <code>Bus</code> <p>bus to which flow is linked</p> required <code>size</code> <code>(scalar, InvestmentParameters)</code> <p>size of the flow. If InvestmentParameters is used, size is optimized. If size is None, a default value is used.</p> <code>None</code> <code>relative_minimum</code> <code>(scalar, array, TimeSeriesData)</code> <p>min value is relative_minimum multiplied by size</p> <code>0</code> <code>relative_maximum</code> <code>(scalar, array, TimeSeriesData)</code> <p>max value is relative_maximum multiplied by size. If size = max then relative_maximum=1</p> <code>1</code> <code>load_factor_min</code> <code>scalar</code> <p>minimal load factor  general: avg Flow per nominalVal/investSize (e.g. boiler, kW/kWh=h; solarthermal: kW/m\u00b2;  def: :math:<code>load\\_factor:= sumFlowHours/ (nominal\\_val \\cdot \\Delta t_{tot})</code></p> <code>None</code> <code>load_factor_max</code> <code>scalar</code> <p>maximal load factor (see minimal load factor)</p> <code>None</code> <code>effects_per_flow_hour</code> <code>(scalar, array, TimeSeriesData)</code> <p>operational costs, costs per flow-\"work\"</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters</code> <p>If present, flow can be \"off\", i.e. be zero (only relevant if relative_minimum &gt; 0) Therefore a binary var \"on\" is used. Further, several other restrictions and effects can be modeled through this On/Off State (See OnOffParameters)</p> <code>None</code> <code>flow_hours_total_max</code> <code>TYPE</code> <p>maximum flow-hours (\"flow-work\") (if size is not const, maybe load_factor_max fits better for you!)</p> <code>None</code> <code>flow_hours_total_min</code> <code>TYPE</code> <p>minimum flow-hours (\"flow-work\") (if size is not const, maybe load_factor_min fits better for you!)</p> <code>None</code> <code>fixed_relative_profile</code> <code>(scalar, array, TimeSeriesData)</code> <p>fixed relative values for flow (if given). val(t) := fixed_relative_profile(t) * size(t) With this value, the flow_rate is no opt-variable anymore; (relative_minimum u. relative_maximum are making sense anymore) used for fixed load profiles, i.g. heat demand, wind-power, solarthermal If the load-profile is just an upper limit, use relative_maximum instead.</p> <code>None</code> <code>previous_flow_rate</code> <code>(scalar, array)</code> <p>previous flow rate of the component.</p> <code>None</code>"},{"location":"api-reference/elements/#flixOpt.elements.Flow-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixOpt.elements.Flow.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/elements/#flixOpt.elements.FlowModel","title":"FlowModel","text":"<pre><code>FlowModel(element: Flow)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/elements/#flixOpt.elements.FlowModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixOpt.elements.FlowModel.with_investment","title":"with_investment  <code>property</code>","text":"<pre><code>with_investment: bool\n</code></pre> <p>Checks if the element's size is investment-driven.</p>"},{"location":"api-reference/elements/#flixOpt.elements.FlowModel.absolute_flow_rate_bounds","title":"absolute_flow_rate_bounds  <code>property</code>","text":"<pre><code>absolute_flow_rate_bounds: Tuple[Numeric, Numeric]\n</code></pre> <p>Returns absolute flow rate bounds. Important for OnOffModel</p>"},{"location":"api-reference/elements/#flixOpt.elements.FlowModel.relative_flow_rate_bounds","title":"relative_flow_rate_bounds  <code>property</code>","text":"<pre><code>relative_flow_rate_bounds: Tuple[Numeric, Numeric]\n</code></pre> <p>Returns relative flow rate bounds.</p>"},{"location":"api-reference/elements/#flixOpt.elements.ComponentModel","title":"ComponentModel","text":"<pre><code>ComponentModel(element: Component)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/elements/#flixOpt.elements.ComponentModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixOpt.elements.ComponentModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling(system_model: SystemModel)\n</code></pre> <p>Initiates all FlowModels</p>"},{"location":"api-reference/elements/#flixOpt.elements-functions","title":"Functions","text":""},{"location":"api-reference/features/","title":"features","text":""},{"location":"api-reference/features/#flixOpt.features","title":"flixOpt.features","text":"<p>This module contains the features of the flixOpt framework. Features extend the functionality of Elements.</p>"},{"location":"api-reference/features/#flixOpt.features-classes","title":"Classes","text":""},{"location":"api-reference/features/#flixOpt.features.InvestmentModel","title":"InvestmentModel","text":"<pre><code>InvestmentModel(element: Union[Flow, Storage], invest_parameters: InvestParameters, defining_variable: [VariableTS], relative_bounds_of_defining_variable: Tuple[Numeric, Numeric], fixed_relative_profile: Optional[Numeric] = None, label: str = 'Investment', on_variable: Optional[VariableTS] = None)\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>Class for modeling an investment</p> <p>If fixed relative profile is used, the relative bounds are ignored</p>"},{"location":"api-reference/features/#flixOpt.features.InvestmentModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixOpt.features.OnOffModel","title":"OnOffModel","text":"<pre><code>OnOffModel(element: Element, on_off_parameters: OnOffParameters, defining_variables: List[VariableTS], defining_bounds: List[Tuple[Numeric, Numeric]], label: str = 'OnOff')\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>Class for modeling the on and off state of a variable If defining_bounds are given, creates sufficient lower bounds</p> <p>defining_bounds: a list of Numeric, that can be  used to create the bound for On/Off more efficiently</p>"},{"location":"api-reference/features/#flixOpt.features.OnOffModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixOpt.features.OnOffModel.get_consecutive_duration","title":"get_consecutive_duration  <code>classmethod</code>","text":"<pre><code>get_consecutive_duration(binary_values: Union[int, ndarray], dt_in_hours: Union[int, float, ndarray]) -&gt; Skalar\n</code></pre> <p>Returns the current consecutive duration in hours, computed from binary values. If only one binary value is availlable, the last dt_in_hours is used. Of both binary_values and dt_in_hours are arrays, checks that the length of dt_in_hours has at least as many elements as the last  consecutive duration in binary_values.</p> <p>Parameters:</p> Name Type Description Default <code>binary_values</code> <code>(int, ndarray)</code> <p>An int or 1D binary array containing only <code>0</code>s and <code>1</code>s.</p> required <code>dt_in_hours</code> <code>(int, float, ndarray)</code> <p>The duration of each time step in hours.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The duration of the binary variable in hours.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the length of binary_values and dt_in_hours is not equal, but None is a scalar.</p>"},{"location":"api-reference/features/#flixOpt.features.SegmentModel","title":"SegmentModel","text":"<pre><code>SegmentModel(element: Element, segment_index: Union[int, str], sample_points: Dict[Variable, Tuple[Union[Numeric, TimeSeries], Union[Numeric, TimeSeries]]], as_time_series: bool = True)\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>Class for modeling a linear segment of one or more variables in parallel</p>"},{"location":"api-reference/features/#flixOpt.features.MultipleSegmentsModel","title":"MultipleSegmentsModel","text":"<pre><code>MultipleSegmentsModel(element: Element, sample_points: Dict[Variable, List[Tuple[Numeric, Numeric]]], can_be_outside_segments: Optional[Union[bool, Variable]], as_time_series: bool = True, label: str = 'MultipleSegments')\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>can_be_outside_segments:    True -&gt; Variable gets created;                             False or None -&gt; No Variable gets_created;                             Variable -&gt; the Variable gets used</p>"},{"location":"api-reference/features/#flixOpt.features.MultipleSegmentsModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixOpt.features.ShareAllocationModel","title":"ShareAllocationModel","text":"<pre><code>ShareAllocationModel(element: Element, label: str, shares_are_time_series: bool, total_max: Optional[Skalar] = None, total_min: Optional[Skalar] = None, max_per_hour: Optional[Numeric] = None, min_per_hour: Optional[Numeric] = None)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/features/#flixOpt.features.ShareAllocationModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixOpt.features.ShareAllocationModel.add_share","title":"add_share","text":"<pre><code>add_share(system_model: SystemModel, name_of_share: str, variable: Optional[Variable], factor: Numeric, share_as_sum: bool = False)\n</code></pre> <p>Adding a Share to a Share Allocation Model.</p>"},{"location":"api-reference/features/#flixOpt.features.SingleShareModel","title":"SingleShareModel","text":"<pre><code>SingleShareModel(element: Element, name: str, variable: Optional[Variable], factor: Numeric, share_as_sum: bool)\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>Holds a Variable and an Equation. Summands can be added to the Equation. Used to publish Shares</p>"},{"location":"api-reference/features/#flixOpt.features.PreventSimultaneousUsageModel","title":"PreventSimultaneousUsageModel","text":"<pre><code>PreventSimultaneousUsageModel(element: Element, variables: List[VariableTS], label: str = 'PreventSimultaneousUsage')\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>Prevents multiple Multiple Binary variables from being 1 at the same time</p> <p>Only 'classic type is modeled for now (# \"classic\" -&gt; alle Flows brauchen Bin\u00e4rvariable:) In 'new', the binary Variables need to be forced beforehand, which is not that straight forward... --&gt; TODO maybe</p>"},{"location":"api-reference/features/#flixOpt.features.PreventSimultaneousUsageModel--new","title":"\"new\":","text":""},{"location":"api-reference/features/#flixOpt.features.PreventSimultaneousUsageModel--eq-flow_1ont-flow_2ont-flow_ivaltflow_imax-1-1-flow-ohne-binarvariable","title":"eq: flow_1.on(t) + flow_2.on(t) + .. + flow_i.val(t)/flow_i.max &lt;= 1 (1 Flow ohne Bin\u00e4rvariable!)","text":""},{"location":"api-reference/features/#flixOpt.features.PreventSimultaneousUsageModel--anmerkung-patrick-schonfeld-oemof-customlinkpy-macht-bei-2-flows-ohne-binarvariable-dies","title":"Anmerkung: Patrick Sch\u00f6nfeld (oemof, custom/link.py) macht bei 2 Flows ohne Bin\u00e4rvariable dies:","text":""},{"location":"api-reference/features/#flixOpt.features.PreventSimultaneousUsageModel--1-bin-flow1flow1_max-1","title":"1)        bin + flow1/flow1_max &lt;= 1","text":""},{"location":"api-reference/features/#flixOpt.features.PreventSimultaneousUsageModel--2-bin-flow2flow2_max-0","title":"2)        bin - flow2/flow2_max &gt;= 0","text":""},{"location":"api-reference/features/#flixOpt.features.PreventSimultaneousUsageModel--3-geht-nur-wenn-alle-flowmin-0","title":"3)    geht nur, wenn alle flow.min &gt;= 0","text":""},{"location":"api-reference/features/#flixOpt.features.PreventSimultaneousUsageModel---konnte-man-auch-umsetzen-statt-force_on_variable-fur-die-flows-aber-sollte-aufs-selbe-wie-new-kommen","title":"--&gt; k\u00f6nnte man auch umsetzen (statt force_on_variable() f\u00fcr die Flows, aber sollte aufs selbe wie \"new\" kommen)","text":""},{"location":"api-reference/features/#flixOpt.features-functions","title":"Functions","text":""},{"location":"api-reference/flow_system/","title":"flow_system","text":""},{"location":"api-reference/flow_system/#flixOpt.flow_system","title":"flixOpt.flow_system","text":"<p>This module contains the FlowSystem class, which is used to collect instances of many other classes by the end User.</p>"},{"location":"api-reference/flow_system/#flixOpt.flow_system-classes","title":"Classes","text":""},{"location":"api-reference/flow_system/#flixOpt.flow_system.FlowSystem","title":"FlowSystem","text":"<pre><code>FlowSystem(time_series: ndarray[datetime64], last_time_step_hours: Optional[Union[int, float]] = None, previous_dt_in_hours: Optional[Union[int, float, ndarray]] = None)\n</code></pre> <p>A FlowSystem organizes the high level Elements (Components &amp; Effects).</p> <p>Parameters:</p> Name Type Description Default <code>time_series</code> <code>np.ndarray of datetime64</code> <p>timeseries of the data. Must be in datetime64 format. Don't use precisions below 'us'. !np.datetime64[ns]!</p> required <code>last_time_step_hours</code> <code>Optional[Union[int, float]]</code> <p>The duration of last time step. Storages needs this time-duration for calculation of charge state after last time step. If None, then last time increment of time_series is used.</p> <code>None</code> <code>previous_dt_in_hours</code> <code>Union[int, float, ndarray]</code> <p>The duration of previous time steps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code>"},{"location":"api-reference/flow_system/#flixOpt.flow_system.FlowSystem-functions","title":"Functions","text":""},{"location":"api-reference/flow_system/#flixOpt.flow_system.FlowSystem.add_elements","title":"add_elements","text":"<pre><code>add_elements(*args: Element) -&gt; None\n</code></pre> <p>add all modeling elements, like storages, boilers, heatpumps, buses, ...</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>childs of  Element like Boiler, HeatPump, Bus,...</code> <p>modeling Elements</p> <code>()</code>"},{"location":"api-reference/flow_system/#flixOpt.flow_system.FlowSystem.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the flow system to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/flow_system/#flixOpt.flow_system.FlowSystem.visualize_network","title":"visualize_network","text":"<pre><code>visualize_network(path: Union[bool, str, Path] = 'flow_system.html', controls: Union[bool, List[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]] = True, show: bool = True) -&gt; Optional[pyvis.network.Network]\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, saving it as an interactive HTML file.</p> <p>Parameters: - path (Union[bool, str, pathlib.Path], default='flow_system.html'):   Path to save the HTML visualization.     - <code>False</code>: Visualization is created but not saved.     - <code>str</code> or <code>Path</code>: Specifies file path (default: 'flow_system.html').</p> <ul> <li> <p>controls (Union[bool, List[str]], default=True):   UI controls to add to the visualization.</p> <ul> <li><code>True</code>: Enables all available controls.</li> <li><code>List</code>: Specify controls, e.g., ['nodes', 'layout'].</li> <li>Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'.</li> </ul> </li> <li> <p>show (bool, default=True):   Whether to open the visualization in the web browser.</p> </li> </ul> <p>Returns: - Optional[pyvis.network.Network]: The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Usage: - Visualize and open the network with default options:</p> <p>self.visualize_network()</p> <ul> <li> <p>Save the visualization without opening:</p> <p>self.visualize_network(show=False)</p> </li> <li> <p>Visualize with custom controls and path:</p> <p>self.visualize_network(path='output/custom_network.html', controls=['nodes', 'layout'])</p> </li> </ul> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/flow_system/#flixOpt.flow_system.FlowSystem.get_time_data_from_indices","title":"get_time_data_from_indices","text":"<pre><code>get_time_data_from_indices(time_indices: Optional[Union[List[int], range]] = None) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.float64]\n</code></pre> <p>Computes time series data based on the provided time indices.</p> <p>Args:     time_indices: A list of indices or a range object indicating which time steps to extract.                   If None, the entire time series is used.</p> <p>Returns:     A tuple containing:     - Extracted time series     - Time series with the \"end time\" appended     - Differences between consecutive timestamps in hours     - Total time in hours</p>"},{"location":"api-reference/flow_system/#flixOpt.flow_system-functions","title":"Functions","text":""},{"location":"api-reference/flow_system/#flixOpt.flow_system.create_datetime_array","title":"create_datetime_array","text":"<pre><code>create_datetime_array(start: str, steps: Optional[int] = None, freq: str = '1h', end: Optional[str] = None) -&gt; np.ndarray[np.datetime64]\n</code></pre> <p>Create a NumPy array with datetime64 values.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>Start date in 'YYYY-MM-DD' format or a full timestamp (e.g., 'YYYY-MM-DD HH:MM').</p> required <code>steps</code> <code>int</code> <p>Number of steps in the datetime array. If <code>end</code> is provided, <code>steps</code> is ignored.</p> <code>None</code> <code>freq</code> <code>str</code> <p>Frequency for the datetime64 array. Supports flexible intervals: - 'Y', 'M', 'W', 'D', 'h', 'm', 's' (e.g., '1h', '15m', '2h'). Defaults to 'h' (hourly).</p> <code>'1h'</code> <code>end</code> <code>str</code> <p>End date in 'YYYY-MM-DD' format or a full timestamp (e.g., 'YYYY-MM-DD HH:MM'). If provided, the function generates an array from <code>start</code> to <code>end</code> using <code>freq</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>NumPy array of datetime64 values.</p> <p>Examples:</p> <p>Create an array with 15-minute intervals:</p> <pre><code>&gt;&gt;&gt; create_datetime_array('2023-01-01', steps=5, freq='15m')\narray(['2023-01-01T00:00', '2023-01-01T00:15', '2023-01-01T00:30', ...], dtype='datetime64[m]')\n</code></pre> <p>Create 2-hour intervals:</p> <pre><code>&gt;&gt;&gt; create_datetime_array('2023-01-01T00', steps=4, freq='2h')\narray(['2023-01-01T00', '2023-01-01T02', '2023-01-01T04', ...], dtype='datetime64[h]')\n</code></pre> <p>Generate minute intervals until a specified end time:</p> <pre><code>&gt;&gt;&gt; create_datetime_array('2023-01-01T00:00', end='2023-01-01T01:00', freq='m')\narray(['2023-01-01T00:00', '2023-01-01T00:01', ..., '2023-01-01T00:59'], dtype='datetime64[m]')\n</code></pre>"},{"location":"api-reference/interface/","title":"interface","text":""},{"location":"api-reference/interface/#flixOpt.interface","title":"flixOpt.interface","text":"<p>This module contains classes to collect Parameters for the Investment and OnOff decisions. These are tightly connected to features.py</p>"},{"location":"api-reference/interface/#flixOpt.interface-classes","title":"Classes","text":""},{"location":"api-reference/interface/#flixOpt.interface.InvestParameters","title":"InvestParameters","text":"<pre><code>InvestParameters(fixed_size: Optional[Union[int, float]] = None, minimum_size: Union[int, float] = 0, maximum_size: Optional[Union[int, float]] = None, optional: bool = True, fix_effects: Union[Dict, int, float] = None, specific_effects: Union[Dict, int, float] = None, effects_in_segments: Optional[Tuple[List[Tuple[Skalar, Skalar]], Dict[Effect, List[Tuple[Skalar, Skalar]]]]] = None, divest_effects: Union[Dict, int, float] = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>collects arguments for invest-stuff</p> <p>Parameters:</p> Name Type Description Default <code>fix_effects</code> <code>None or scalar</code> <p>Fixed investment costs if invested. (Attention: Annualize costs to chosen period!)</p> <code>None</code> <code>divest_effects</code> <code>None or scalar</code> <p>Fixed divestment costs (if not invested, e.g., demolition costs or contractual penalty).</p> <code>None</code> <code>fixed_size</code> <code>(int, float)</code> <p>Determines if the investment size is fixed.</p> <code>None</code> <code>optional</code> <code>bool</code> <p>If True, investment is not forced.</p> <code>True</code> <code>specific_effects</code> <code>scalar or Dict[Effect: Union[int, float, np.ndarray]</code> <p>Specific costs, e.g., in \u20ac/kW_nominal or \u20ac/m\u00b2_nominal. Example: {costs: 3, CO2: 0.3} with costs and CO2 representing an Object of class Effect (Attention: Annualize costs to chosen period!)</p> <code>None</code> <code>effects_in_segments</code> <code>list or List[ List[Union[int,float]], Dict[cEffecType: Union[List[Union[int,float]]</code> <p>Linear relation in segments [invest_segments, cost_segments]. Example 1:     [           [5, 25, 25, 100],       # size in kW      {costs:    [50,250,250,800],       # \u20ac       PE:       [5, 25, 25, 100]        # kWh_PrimaryEnergy       }     ] Example 2 (if only standard-effect):     [   [5, 25, 25, 100],  # kW # size in kW         [50,250,250,800]        # value for standart effect, typically \u20ac      ]  # \u20ac (Attention: Annualize costs to chosen period!) (Args 'specific_effects' and 'fix_effects' can be used in parallel to InvestsizeSegments)</p> <code>None</code> <code>minimum_size</code> <code>scalar</code> <p>Min nominal value (only if: size_is_fixed = False).</p> <code>0</code> <code>maximum_size</code> <code>(scalar, Optional)</code> <p>Max nominal value (only if: size_is_fixed = False).</p> <code>None</code>"},{"location":"api-reference/interface/#flixOpt.interface.InvestParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixOpt.interface.InvestParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixOpt.interface.InvestParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/interface/#flixOpt.interface.OnOffParameters","title":"OnOffParameters","text":"<pre><code>OnOffParameters(effects_per_switch_on: Union[Dict, Numeric] = None, effects_per_running_hour: Union[Dict, Numeric] = None, on_hours_total_min: Optional[int] = None, on_hours_total_max: Optional[int] = None, consecutive_on_hours_min: Optional[Numeric] = None, consecutive_on_hours_max: Optional[Numeric] = None, consecutive_off_hours_min: Optional[Numeric] = None, consecutive_off_hours_max: Optional[Numeric] = None, switch_on_total_max: Optional[int] = None, force_switch_on: bool = False)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>on_off_parameters class for modeling on and off state of an Element. If no parameters are given, the default is to create a binary variable for the on state without further constraints or effects and a variable for the total on hours.</p> <p>Parameters:</p> Name Type Description Default <code>effects_per_switch_on</code> <code>(scalar, array, TimeSeriesData)</code> <p>cost of one switch from off (var_on=0) to on (var_on=1), unit i.g. in Euro</p> <code>None</code> <code>effects_per_running_hour</code> <code>scalar or TS</code> <p>costs for operating, i.g. in \u20ac per hour</p> <code>None</code> <code>on_hours_total_min</code> <code>scalar</code> <p>min. overall sum of operating hours.</p> <code>None</code> <code>on_hours_total_max</code> <code>scalar</code> <p>max. overall sum of operating hours.</p> <code>None</code> <code>consecutive_on_hours_min</code> <code>scalar</code> <p>min sum of operating hours in one piece (last on-time period of timeseries is not checked and can be shorter)</p> <code>None</code> <code>consecutive_on_hours_max</code> <code>scalar</code> <p>max sum of operating hours in one piece</p> <code>None</code> <code>consecutive_off_hours_min</code> <code>scalar</code> <p>min sum of non-operating hours in one piece (last off-time period of timeseries is not checked and can be shorter)</p> <code>None</code> <code>consecutive_off_hours_max</code> <code>scalar</code> <p>max sum of non-operating hours in one piece</p> <code>None</code> <code>switch_on_total_max</code> <code>integer</code> <p>max nr of switchOn operations</p> <code>None</code> <code>force_switch_on</code> <code>bool</code> <p>force creation of switch on variable, even if there is no switch_on_total_max</p> <code>False</code>"},{"location":"api-reference/interface/#flixOpt.interface.OnOffParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixOpt.interface.OnOffParameters.use_off","title":"use_off  <code>property</code>","text":"<pre><code>use_off: bool\n</code></pre> <p>Determines wether the OFF Variable is needed or not</p>"},{"location":"api-reference/interface/#flixOpt.interface.OnOffParameters.use_consecutive_on_hours","title":"use_consecutive_on_hours  <code>property</code>","text":"<pre><code>use_consecutive_on_hours: bool\n</code></pre> <p>Determines wether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/interface/#flixOpt.interface.OnOffParameters.use_consecutive_off_hours","title":"use_consecutive_off_hours  <code>property</code>","text":"<pre><code>use_consecutive_off_hours: bool\n</code></pre> <p>Determines wether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/interface/#flixOpt.interface.OnOffParameters.use_switch_on","title":"use_switch_on  <code>property</code>","text":"<pre><code>use_switch_on: bool\n</code></pre> <p>Determines wether a Variable for SWITCH-ON is needed or not</p>"},{"location":"api-reference/interface/#flixOpt.interface.OnOffParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixOpt.interface.OnOffParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixOpt.interface.OnOffParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/linear_converters/","title":"linear_converters","text":""},{"location":"api-reference/linear_converters/#flixOpt.linear_converters","title":"flixOpt.linear_converters","text":"<p>This Module contains high-level classes to easily model a FlowSystem.</p>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters-classes","title":"Classes","text":""},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.Boiler","title":"Boiler","text":"<pre><code>Boiler(label: str, eta: Numeric_TS, Q_fu: Flow, Q_th: Flow, on_off_parameters: OnOffParameters = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>constructor for boiler</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of bolier.</p> required <code>eta</code> <code>float or TS</code> <p>thermal efficiency.</p> required <code>Q_fu</code> <code>Flow</code> <p>fuel input-flow</p> required <code>Q_th</code> <code>Flow</code> <p>thermal output-flow.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.Boiler-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.Boiler.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.Power2Heat","title":"Power2Heat","text":"<pre><code>Power2Heat(label: str, eta: Numeric_TS, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of bolier.</p> required <code>eta</code> <code>float or TS</code> <p>thermal efficiency.</p> required <code>P_el</code> <code>Flow</code> <p>electric input-flow</p> required <code>Q_th</code> <code>Flow</code> <p>thermal output-flow.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.Power2Heat-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.Power2Heat.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.HeatPump","title":"HeatPump","text":"<pre><code>HeatPump(label: str, COP: Numeric_TS, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of heatpump.</p> required <code>COP</code> <code>float or TS</code> <p>Coefficient of performance.</p> required <code>P_el</code> <code>Flow</code> <p>electricity input-flow.</p> required <code>Q_th</code> <code>Flow</code> <p>thermal output-flow.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.HeatPump-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.HeatPump.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.CoolingTower","title":"CoolingTower","text":"<pre><code>CoolingTower(label: str, specific_electricity_demand: Numeric_TS, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of cooling tower.</p> required <code>specific_electricity_demand</code> <code>float or TS</code> <p>auxiliary electricty demand per cooling power, i.g. 0.02 (2 %).</p> required <code>P_el</code> <code>Flow</code> <p>electricity input-flow.</p> required <code>Q_th</code> <code>Flow</code> <p>thermal input-flow.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.CoolingTower-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.CoolingTower.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.CHP","title":"CHP","text":"<pre><code>CHP(label: str, eta_th: Numeric_TS, eta_el: Numeric_TS, Q_fu: Flow, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>constructor of cCHP</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of CHP-unit.</p> required <code>eta_th</code> <code>float or TS</code> <p>thermal efficiency.</p> required <code>eta_el</code> <code>float or TS</code> <p>electrical efficiency.</p> required <code>Q_fu</code> <code>cFlow</code> <p>fuel input-flow.</p> required <code>P_el</code> <code>cFlow</code> <p>electricity output-flow.</p> required <code>Q_th</code> <code>cFlow</code> <p>heat output-flow.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.CHP-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.CHP.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.HeatPumpWithSource","title":"HeatPumpWithSource","text":"<pre><code>HeatPumpWithSource(label: str, COP: Numeric_TS, P_el: Flow, Q_ab: Flow, Q_th: Flow, on_off_parameters: OnOffParameters = None, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>name of heatpump.</p> required <code>COP</code> <code>(float, TS)</code> <p>Coefficient of performance.</p> required <code>Q_ab</code> <code>Flow</code> <p>Heatsource input-flow.</p> required <code>P_el</code> <code>Flow</code> <p>electricity input-flow.</p> required <code>Q_th</code> <code>Flow</code> <p>thermal output-flow.</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.HeatPumpWithSource-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.HeatPumpWithSource.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/linear_converters/#flixOpt.linear_converters-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixOpt.linear_converters.check_bounds","title":"check_bounds","text":"<pre><code>check_bounds(value: Numeric_TS, parameter_label: str, element_label: str, lower_bound: Numeric_TS, upper_bound: Numeric_TS)\n</code></pre> <p>Check if the value is within the bounds. The bounds are exclusive. If not, log a warning.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Numeric_TS</code> <p>The value to check.</p> required <code>parameter_label</code> <code>str</code> <p>The label of the value.</p> required <code>element_label</code> <code>str</code> <p>The label of the element.</p> required <code>lower_bound</code> <code>Numeric_TS</code> <p>The lower bound.</p> required <code>upper_bound</code> <code>Numeric_TS</code> <p>The upper bound.</p> required"},{"location":"api-reference/math_modeling/","title":"math_modeling","text":""},{"location":"api-reference/math_modeling/#flixOpt.math_modeling","title":"flixOpt.math_modeling","text":"<p>This module contains the mathematical core of the flixOpt framework. THe module is designed to be used by other modules than flixOpt itself. It holds all necessary classes and functions to create a mathematical model, consisting of Varaibles and constraints, and translate it into a ModelingLanguage like Pyomo, and the solve it through a solver. Multiple solvers are supported.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling-classes","title":"Classes","text":""},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Variable","title":"Variable","text":"<pre><code>Variable(label: str, length: int, label_short: Optional[str] = None, is_binary: bool = False, fixed_value: Optional[Numeric] = None, lower_bound: Optional[Numeric] = None, upper_bound: Optional[Numeric] = None)\n</code></pre> <p>Variable class</p> <p>label: full label of the variable label_short: short label of the variable</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Variable--todo-allow-for-none-values-in-fixed_value-if-none-the-index-gets-not-fixed","title":"TODO: Allow for None values in fixed_value. If None, the index gets not fixed!","text":""},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Variable-functions","title":"Functions","text":""},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.VariableTS","title":"VariableTS","text":"<pre><code>VariableTS(label: str, length: int, label_short: Optional[str] = None, is_binary: bool = False, fixed_value: Optional[Numeric] = None, lower_bound: Optional[Numeric] = None, upper_bound: Optional[Numeric] = None, previous_values: Optional[Numeric] = None)\n</code></pre> <p>               Bases: <code>Variable</code></p> <p>Timeseries-Variable, optionally with previous_values. class for Variables that are related by time</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Equation","title":"Equation","text":"<pre><code>Equation(label, label_short=None, is_objective=False)\n</code></pre> <p>               Bases: <code>_Constraint</code></p> <p>Equation of the form: \u2211() =  Can be the Objective of a MathModel. <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Full label of the variable.</p> required <code>label_short</code> <code>str</code> <p>Short label of the variable. If None, the full label is used.</p> <code>None</code> <code>is_objective</code> <code>bool</code> <p>Indicates if this equation is the objective of the model (default is False).</p> <code>False</code>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Equation-functions","title":"Functions","text":""},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Equation.add_summand","title":"add_summand","text":"<pre><code>add_summand(variable: Variable, factor: Numeric, indices_of_variable: Optional[Union[int, ndarray, range, List[int]]] = None, as_sum: bool = False) -&gt; None\n</code></pre> <p>Adds a summand to the left side of the equation.</p> <p>This method creates a summand from the given variable and factor, optionally summing over all given indices. The summand is then added to the summands of the equation, which represent the left side.</p> Parameters: <p>variable : Variable     The variable to be used in the summand. factor : Numeric     The factor by which the variable is multiplied. indices_of_variable : Optional[Numeric], optional     Specific indices of the variable to be used. If not provided, all indices are used. as_sum : bool, optional     If True, the summand is treated as a sum over all indices of the variable.</p> Raises: <p>TypeError     If the provided variable is not an instance of the Variable class. ValueError     If the variable is None and as_sum is True. ValueError     If the length doesnt match the Equation's length.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Equation.add_constant","title":"add_constant","text":"<pre><code>add_constant(value: Numeric) -&gt; None\n</code></pre> <p>Adds a constant value to the rigth side of the equation</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float or array</code> <p>constant-value of equation [Ax = constant] or [Ax &lt;= constant]</p> required <p>Returns:</p> Type Description <code>None.</code> Raises: <p>ValueError     If the length doesnt match the Equation's length.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Inequation","title":"Inequation","text":"<pre><code>Inequation(label, label_short=None)\n</code></pre> <p>               Bases: <code>_Constraint</code></p> <p>Equation of the form:  &gt;= \u2211()"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Inequation-functions","title":"Functions","text":""},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Inequation.add_summand","title":"add_summand","text":"<pre><code>add_summand(variable: Variable, factor: Numeric, indices_of_variable: Optional[Union[int, ndarray, range, List[int]]] = None, as_sum: bool = False) -&gt; None\n</code></pre> <p>Adds a summand to the left side of the equation.</p> <p>This method creates a summand from the given variable and factor, optionally summing over all given indices. The summand is then added to the summands of the equation, which represent the left side.</p> Parameters: <p>variable : Variable     The variable to be used in the summand. factor : Numeric     The factor by which the variable is multiplied. indices_of_variable : Optional[Numeric], optional     Specific indices of the variable to be used. If not provided, all indices are used. as_sum : bool, optional     If True, the summand is treated as a sum over all indices of the variable.</p> Raises: <p>TypeError     If the provided variable is not an instance of the Variable class. ValueError     If the variable is None and as_sum is True. ValueError     If the length doesnt match the Equation's length.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Inequation.add_constant","title":"add_constant","text":"<pre><code>add_constant(value: Numeric) -&gt; None\n</code></pre> <p>Adds a constant value to the rigth side of the equation</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float or array</code> <p>constant-value of equation [Ax = constant] or [Ax &lt;= constant]</p> required <p>Returns:</p> Type Description <code>None.</code> Raises: <p>ValueError     If the length doesnt match the Equation's length.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Summand","title":"Summand","text":"<pre><code>Summand(variable: Variable, factor: Numeric, indices: Optional[Union[int, ndarray, range, List[int]]] = None)\n</code></pre> <p>Represents a part of a Constraint , consisting of a variable (or a time-series variable) and a factor.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>Variable</code> <p>The variable associated with this summand.</p> required <code>factor</code> <code>Numeric</code> <p>The factor by which the variable is multiplied in the equation.</p> required <code>indices</code> <code>(int, ndarray, range, List[int])</code> <p>Specifies which indices of the variable to use. If None, all indices of the variable are used.</p> <code>None</code>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.SumOfSummand","title":"SumOfSummand","text":"<pre><code>SumOfSummand(variable: Variable, factor: Numeric, indices: Optional[Union[int, ndarray, range, List[int]]] = None)\n</code></pre> <p>               Bases: <code>Summand</code></p> <p>Represents a part of an Equation that sums all components of a regular Summand over specified indices.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>Variable</code> <p>The variable associated with this summand.</p> required <code>factor</code> <code>Numeric</code> <p>The factor by which the variable is multiplied.</p> required <code>indices</code> <code>(int, ndarray, range, List[int])</code> <p>Specifies which indices of the variable to use for the sum. If None, all indices are summed.</p> <code>None</code>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.MathModel","title":"MathModel","text":"<pre><code>MathModel(label: str, modeling_language: Literal['pyomo', 'cvxpy'] = 'pyomo')\n</code></pre> <p>A mathematical model for defining equations and constraints of the form:</p> <pre><code>a1 * x1 + a2 + x2  = y\nand\na1 * x1 + a2 + x2 &lt;= y\n</code></pre> <p>where 'a1', 'a2' and y can be vectors or scalars, while 'x1' and 'x2' are variables with an appropriate length.</p> <p>This class provides methods to add variables, equations, and inequality constraints to the model and supports translation to a specified modeling language like pyomo.</p> <p>The expression 'a1 * x1' is referred to as a 'Summand'. Supported summand formats are: - 'Variable[j] * Factor[i]'     : Multiplication of vector variables and vector factors. - 'Variable[j] * Factor'        : Vector variable with scalar factor. - 'Variable    * Factor'        : Scalar variable with scalar factor. - 'Factor'                      : Scalar constant.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>A descriptive label for the model.</p> required <code>modeling_language</code> <code>(pyomo, cvxpy)</code> <p>Specifies the modeling language used for translation (default is 'pyomo').</p> <code>'pyomo'</code> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>The label assigned to the model.</p> <code>modeling_language</code> <code>str</code> <p>The modeling language to which the model will be translated.</p> <code>epsilon</code> <code>float</code> <p>Small tolerance value used in model calculations, defaulting to <code>1e-5</code>.</p> <code>solver</code> <code>Optional[Solver]</code> <p>The solver instance assigned to solve the model.</p> <code>model</code> <code>Optional[ModelingLanguage]</code> <p>The model instance in the specified modeling language.</p> <code>_variables</code> <code>List[Variable]</code> <p>List of variables added to the model.</p> <code>_constraints</code> <code>List[Union[Equation, Inequation]]</code> <p>List of equations and inequality constraints in the model.</p> <code>_objective</code> <code>Optional[Equation]</code> <p>The objective function, if defined as an equation.</p> <code>duration</code> <code>dict</code> <p>Dictionary tracking the time taken for translation and solving steps.</p> <p>Methods:</p> Name Description <code>add</code> <p>Adds variables, equations, or inequations to the model.</p> <code>describe_size</code> <p>Provides a summary of the number of equations, inequations, and variables.</p> <code>translate_to_modeling_language</code> <p>Translates the model to the specified modeling language.</p> <code>solve</code> <p>Solves the model using the specified solver instance.</p> <code>results</code> <p>Returns a dictionary of variable results after solving.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.SolverLog","title":"SolverLog","text":"<pre><code>SolverLog(solver_name: str, filename: str)\n</code></pre> <p>Parses and holds solver log information for specific solvers.</p> <p>Attributes:     solver_name (str): Name of the solver (e.g., 'gurobi', 'cbc').     log (str): Content of the log file.     presolved_rows (Optional[int]): Number of rows after presolving.     presolved_cols (Optional[int]): Number of columns after presolving.     presolved_nonzeros (Optional[int]): Number of nonzeros after presolving.     presolved_continuous (Optional[int]): Number of continuous variables after presolving.     presolved_integer (Optional[int]): Number of integer variables after presolving.     presolved_binary (Optional[int]): Number of binary variables after presolving.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.Solver","title":"Solver","text":"<pre><code>Solver(mip_gap: float, solver_output_to_console: bool, logfile_name: str)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for solvers.</p> <p>Attributes:     mip_gap (float): Solver's mip gap setting. The MIP gap describes the accepted (MILP) objective,         and the lower bound, which is the theoretically optimal solution (LP)     solver_output_to_console (bool): Whether to display solver output.     logfile_name (str): Filename for saving the solver log.     objective (Optional[float]): Objective value from the solution.     best_bound (Optional[float]): Best bound from the solver.     termination_message (Optional[str]): Solver's termination message.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.GurobiSolver","title":"GurobiSolver","text":"<pre><code>GurobiSolver(mip_gap: float = 0.01, time_limit_seconds: int = 300, logfile_name: str = 'gurobi.log', solver_output_to_console: bool = True)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for Gurobi. Also Look in class Solver for more details</p> <p>Attributes:     time_limit_seconds (int): Time limit for the solver. After this time, the solver takes the currently     best solution, ignoring the mip_gap.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.CplexSolver","title":"CplexSolver","text":"<pre><code>CplexSolver(mip_gap: float = 0.01, time_limit_seconds: int = 300, logfile_name: str = 'cplex.log', solver_output_to_console: bool = True)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for CPLEX. Also Look in class Solver for more details</p> <p>Attributes:     time_limit_seconds (int): Time limit for the solver. After this time, the solver takes the currently     best solution, ignoring the mip_gap.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.HighsSolver","title":"HighsSolver","text":"<pre><code>HighsSolver(mip_gap: float = 0.01, time_limit_seconds: int = 300, logfile_name: str = 'highs.log', solver_output_to_console: bool = True, threads: int = 4)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for HIGHS. Also Look in class Solver for more details</p> <p>Attributes:     time_limit_seconds (int): Time limit for the solver. After this time, the solver takes the currently     best solution, ignoring the mip_gap.     threads (int): Number of threads to use for the solver.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.CbcSolver","title":"CbcSolver","text":"<pre><code>CbcSolver(mip_gap: float = 0.01, time_limit_seconds: int = 300, logfile_name: str = 'cbc.log', solver_output_to_console: bool = True)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for CBC. Also Look in class Solver for more details</p> <p>Attributes:     time_limit_seconds (int): Time limit for the solver. After this time, the solver takes the currently     best solution, ignoring the mip_gap.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.GlpkSolver","title":"GlpkSolver","text":"<pre><code>GlpkSolver(mip_gap: float = 0.01, logfile_name: str = 'glpk.log', solver_output_to_console: bool = True)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for Glpk. Also Look in class Solver for more details</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.ModelingLanguage","title":"ModelingLanguage","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for modeling languages.</p> <p>Methods:     translate_model(model): Translates a math model into a solveable form.</p>"},{"location":"api-reference/math_modeling/#flixOpt.math_modeling.PyomoModel","title":"PyomoModel","text":"<pre><code>PyomoModel()\n</code></pre> <p>               Bases: <code>ModelingLanguage</code></p> <p>Pyomo-based modeling language for constructing and solving optimization models. Translates a MathModel into a PyomoModel.</p> <p>Attributes:     model: Pyomo model instance.     mapping (dict): Maps variables and equations to Pyomo components.     _counter (int): Counter for naming Pyomo components.</p>"},{"location":"api-reference/plotting/","title":"plotting","text":""},{"location":"api-reference/plotting/#flixOpt.plotting","title":"flixOpt.plotting","text":"<p>This module contains the plotting functionality of the flixOpt framework. It provides high level functions to plot data with plotly and matplotlib. It's meant to be used in results.py, but is designed to be used by the end user as well.</p>"},{"location":"api-reference/plotting/#flixOpt.plotting-functions","title":"Functions","text":""},{"location":"api-reference/plotting/#flixOpt.plotting.with_plotly","title":"with_plotly","text":"<pre><code>with_plotly(data: DataFrame, mode: Literal['bar', 'line', 'area'] = 'area', colors: Union[List[str], str] = 'viridis', title: str = '', ylabel: str = '', fig: Optional[Figure] = None, show: bool = False, save: bool = False, path: Union[str, Path] = 'temp-plot.html') -&gt; go.Figure\n</code></pre> <p>Plot a DataFrame with Plotly, using either stacked bars or stepped lines.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot, where the index represents time (e.g., hours), and each column represents a separate data series.</p> required <code>mode</code> <code>(bar, line)</code> <p>The plotting mode. Use 'bar' for stacked bar charts or 'line' for stepped lines.</p> <code>'bar'</code> <code>colors</code> <code>(List[str], str)</code> <p>A List of colors (as str) or a name of a colorscale (e.g., 'viridis', 'plasma') to use for coloring the data series.</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis.</p> <code>''</code> <code>fig</code> <code>Figure</code> <p>A Plotly figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Wether to show the figure after creation. (This includes saving the figure)</p> <code>False</code> <code>save</code> <code>bool</code> <p>Wether to save the figure after creation (without showing)</p> <code>False</code> <code>path</code> <code>Union[str, Path]</code> <p>Path to save the figure.</p> <code>'temp-plot.html'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the generated plot.</p> Notes <ul> <li>If <code>mode</code> is 'bar', bars are stacked for each data series.</li> <li>If <code>mode</code> is 'line', a stepped line is drawn for each data series.</li> <li>The legend is positioned below the plot for a cleaner layout when many   data series are present.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = with_plotly(data, mode='bar', colorscale='plasma')\n&gt;&gt;&gt; fig.show()\n</code></pre>"},{"location":"api-reference/plotting/#flixOpt.plotting.with_matplotlib","title":"with_matplotlib","text":"<pre><code>with_matplotlib(data: DataFrame, mode: Literal['bar', 'line'] = 'bar', colors: Union[List[str], str] = 'viridis', figsize: Tuple[int, int] = (12, 6), fig: Optional[Figure] = None, ax: Optional[Axes] = None, show: bool = False, path: Optional[Union[str, Path]] = None) -&gt; Tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot a DataFrame with Matplotlib using stacked bars or stepped lines.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot. The index should represent time (e.g., hours), and each column represents a separate data series.</p> required <code>mode</code> <code>(bar, line)</code> <p>Plotting mode. Use 'bar' for stacked bar charts or 'line' for stepped lines.</p> <code>'bar'</code> <code>colors</code> <code>(List[str], str)</code> <p>A List of colors (as str) or a name of a colorscale (e.g., 'viridis', 'plasma') to use for coloring the data series.</p> <code>'viridis'</code> <code>figsize</code> <code>Tuple[int, int]</code> <p>Specify the size of the figure</p> <code>(12, 6)</code> <code>fig</code> <code>Figure</code> <p>A Matplotlib figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>A Matplotlib axes object to plot on. If not provided, a new axes will be created.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Wether to show the figure after creation.</p> <code>False</code> <code>path</code> <code>Optional[Union[str, Path]]</code> <p>Path to save the figure to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Figure, Axes]</code> <p>A tuple containing the Matplotlib figure and axes objects used for the plot.</p> Notes <ul> <li>If <code>mode</code> is 'bar', bars are stacked for both positive and negative values.   Negative values are stacked separately without extra labels in the legend.</li> <li>If <code>mode</code> is 'line', stepped lines are drawn for each data series.</li> <li>The legend is placed below the plot to accommodate multiple data series.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig, ax = with_matplotlib(data, mode='bar', colorscale='plasma')\n&gt;&gt;&gt; plt.show()\n</code></pre>"},{"location":"api-reference/plotting/#flixOpt.plotting.heat_map_matplotlib","title":"heat_map_matplotlib","text":"<pre><code>heat_map_matplotlib(data: DataFrame, color_map: str = 'viridis', figsize: Tuple[float, float] = (12, 6), show: bool = False, path: Optional[Union[str, Path]] = None) -&gt; Tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plots a DataFrame as a heatmap using Matplotlib. The columns of the DataFrame will be displayed on the x-axis, the index will be displayed on the y-axis, and the values will represent the 'heat' intensity in the plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to be visualized. The index will be used for the y-axis, and columns will be used for the x-axis. The values in the DataFrame will be represented as colors in the heatmap.</p> required <code>color_map</code> <code>str</code> <p>The colormap to use for the heatmap. Default is 'viridis'. Matplotlib supports various colormaps like 'plasma', 'inferno', 'cividis', etc.</p> <code>'viridis'</code> <code>figsize</code> <code>tuple of float</code> <p>The size of the figure to create. Default is (12, 6), which results in a width of 12 inches and a height of 6 inches.</p> <code>(12, 6)</code> <code>show</code> <code>bool</code> <p>Wether to show the figure after creation.</p> <code>False</code> <code>path</code> <code>Optional[Union[str, Path]]</code> <p>Path to save the figure to.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple of (plt.Figure, plt.Axes)</code> <p>A tuple containing the Matplotlib <code>Figure</code> and <code>Axes</code> objects. The <code>Figure</code> contains the overall plot, while the <code>Axes</code> is the area where the heatmap is drawn. These can be used for further customization or saving the plot to a file.</p> Notes <ul> <li>The y-axis is flipped so that the first row of the DataFrame is displayed at the top of the plot.</li> <li>The color scale is normalized based on the minimum and maximum values in the DataFrame.</li> <li>The x-axis labels (periods) are placed at the top of the plot.</li> <li>The colorbar is added horizontally at the bottom of the plot, with a label.</li> </ul>"},{"location":"api-reference/plotting/#flixOpt.plotting.heat_map_plotly","title":"heat_map_plotly","text":"<pre><code>heat_map_plotly(data: DataFrame, color_map: str = 'viridis', title: str = '', xlabel: str = 'Periods', ylabel: str = 'Step', categorical_labels: bool = True, show: bool = False, save: bool = False, path: Union[str, Path] = 'temp-plot.html') -&gt; go.Figure\n</code></pre> <p>Plots a DataFrame as a heatmap using Plotly. The columns of the DataFrame will be mapped to the x-axis, and the index will be displayed on the y-axis. The values in the DataFrame will represent the 'heat' in the plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame with the data to be visualized. The index will be used for the y-axis, and columns will be used for the x-axis. The values in the DataFrame will be represented as colors in the heatmap.</p> required <code>color_map</code> <code>str</code> <p>The color scale to use for the heatmap. Default is 'viridis'. Plotly supports various color scales like 'Cividis', 'Inferno', etc.</p> <code>'viridis'</code> <code>categorical_labels</code> <code>bool</code> <p>If True, the x and y axes are treated as categorical data (i.e., the index and columns will not be interpreted as continuous data). Default is True. If False, the axes are treated as continuous, which may be useful for time series or numeric data.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Wether to show the figure after creation. (This includes saving the figure)</p> <code>False</code> <code>save</code> <code>bool</code> <p>Wether to save the figure after creation (without showing)</p> <code>False</code> <code>path</code> <code>Union[str, Path]</code> <p>Path to save the figure.</p> <code>'temp-plot.html'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the heatmap. This can be further customized and saved or displayed using <code>fig.show()</code>.</p> Notes <p>The color bar is automatically scaled to the minimum and maximum values in the data. The y-axis is reversed to display the first row at the top.</p>"},{"location":"api-reference/plotting/#flixOpt.plotting.reshape_to_2d","title":"reshape_to_2d","text":"<pre><code>reshape_to_2d(data_1d: ndarray, nr_of_steps_per_column: int) -&gt; np.ndarray\n</code></pre> <p>Reshapes a 1D numpy array into a 2D array suitable for plotting as a colormap.</p> <p>The reshaped array will have the number of rows corresponding to the steps per column (e.g., 24 hours per day) and columns representing time periods (e.g., days or months).</p> <p>Parameters:</p> Name Type Description Default <code>data_1d</code> <code>ndarray</code> <p>A 1D numpy array with the data to reshape.</p> required <code>nr_of_steps_per_column</code> <code>int</code> <p>The number of steps (rows) per column in the resulting 2D array. For example, this could be 24 (for hours) or 31 (for days in a month).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The reshaped 2D array. Each internal array corresponds to one column, with the specified number of steps. Each column might represents a time period (e.g., day, month, etc.).</p>"},{"location":"api-reference/plotting/#flixOpt.plotting.heat_map_data_from_df","title":"heat_map_data_from_df","text":"<pre><code>heat_map_data_from_df(df: DataFrame, periods: Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], steps_per_period: Literal['W', 'D', 'h', '15min', 'min'], fill: Optional[Literal['ffill', 'bfill']] = None) -&gt; pd.DataFrame\n</code></pre> <p>Reshapes a DataFrame with a DateTime index into a 2D array for heatmap plotting, based on a specified sample rate. If a non-valid combination of periods and steps per period is used, falls back to numerical indices</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A DataFrame with a DateTime index containing the data to reshape.</p> required <code>periods</code> <code>str</code> <p>The time interval of each period (columns of the heatmap), such as 'YS' (year start), 'W' (weekly), 'D' (daily), 'h' (hourly) etc.</p> required <code>steps_per_period</code> <code>str</code> <p>The time interval within each period (rows in the heatmap), such as 'YS' (year start), 'W' (weekly), 'D' (daily), 'h' (hourly) etc.</p> required <code>fill</code> <code>str</code> <p>Method to fill missing values: 'ffill' for forward fill or 'bfill' for backward fill.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame suitable for heatmap plotting, with rows representing steps within each period and columns representing each period.</p>"},{"location":"api-reference/plotting/#flixOpt.plotting.visualize_network","title":"visualize_network","text":"<pre><code>visualize_network(node_infos: dict, edge_infos: dict, path: Optional[Union[str, Path]] = None, controls: Union[bool, List[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]] = True, show: bool = True) -&gt; Optional[pyvis.network.Network]\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, using info-dictionaries.</p> <p>Parameters: - path (Union[bool, str, pathlib.Path], default='results/network.html'):   Path to save the HTML visualization.     - <code>False</code>: Visualization is created but not saved.     - <code>str</code> or <code>Path</code>: Specifies file path (default: 'results/network.html').</p> <ul> <li> <p>controls (Union[bool, List[str]], default=True):   UI controls to add to the visualization.</p> <ul> <li><code>True</code>: Enables all available controls.</li> <li><code>List</code>: Specify controls, e.g., ['nodes', 'layout'].</li> <li>Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'. You can play with these and generate a Dictionary from it that can be applied to the network returned by this function. network.set_options() https://pyvis.readthedocs.io/en/latest/tutorial.html</li> </ul> </li> <li> <p>show (bool, default=True):   Whether to open the visualization in the web browser.   The calculation must be saved to show it. If no path is given, it defaults to 'network.html'.</p> </li> </ul> <p>Returns: - Optional[pyvis.network.Network]: The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Usage: - Visualize and open the network with default options:</p> <p>self.visualize_network()</p> <ul> <li> <p>Save the visualization without opening:</p> <p>self.visualize_network(show=False)</p> </li> <li> <p>Visualize with custom controls and path:</p> <p>self.visualize_network(path='output/custom_network.html', controls=['nodes', 'layout'])</p> </li> </ul> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/results/","title":"results","text":""},{"location":"api-reference/results/#flixOpt.results","title":"flixOpt.results","text":"<p>This module contains the Results functionality of the flixOpt framework. It provides high level functions to analyze the results of a calculation. It leverages the plotting.py module to plot the results. The results can also be analyzed without this module, as the results are stored in a widely supported format.</p>"},{"location":"api-reference/results/#flixOpt.results-classes","title":"Classes","text":""},{"location":"api-reference/results/#flixOpt.results.CalculationResults","title":"CalculationResults","text":"<pre><code>CalculationResults(calculation_name: str, folder: str)\n</code></pre>"},{"location":"api-reference/results/#flixOpt.results.CalculationResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixOpt.results.CalculationResults.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe(label: str, variable_name: str = 'flow_rate', input_factor: Optional[Literal[1, -1]] = -1, output_factor: Optional[Literal[1, -1]] = 1, threshold: Optional[float] = 1e-05, with_last_time_step: bool = True) -&gt; pd.DataFrame\n</code></pre> <p>Convert results of a specified element to a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the element (Component, Bus, or Flow) to retrieve data for.</p> required <code>variable_name</code> <code>str</code> <p>The name of the variable to extract from the element's data.</p> <code>'flow_rate'</code> <code>input_factor</code> <code>Optional[Literal[1, -1]]</code> <p>Factor to apply to input values.</p> <code>-1</code> <code>output_factor</code> <code>Optional[Literal[1, -1]]</code> <p>Factor to apply to output values.</p> <code>1</code> <code>threshold</code> <code>Optional[float]</code> <p>Minimum absolute value for data inclusion in the DataFrame.</p> <code>1e-5</code> <code>with_last_time_step</code> <code>bool</code> <p>Whether to include the last time step in the DataFrame index.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the specified variable's data with a datetime index. Dataframe is empty (no index), if no values are left after filtering.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no data is found for the specified variable.</p>"},{"location":"api-reference/results/#flixOpt.results.CalculationResults.plot_operation","title":"plot_operation","text":"<pre><code>plot_operation(label: str, mode: Literal['bar', 'line', 'area', 'heatmap'] = 'area', variable_name: str = 'flow_rate', heatmap_periods: Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'] = 'D', heatmap_steps_per_period: Literal['W', 'D', 'h', '15min', 'min'] = 'h', colors: Union[str, List[str]] = 'viridis', engine: Literal['plotly', 'matplotlib'] = 'plotly', invert: bool = True, show: bool = True, save: bool = False, path: Union[str, Path, Literal['auto']] = 'auto') -&gt; Union[go.Figure, Tuple[plt.Figure, plt.Axes]]\n</code></pre> <p>Plots the operation results for a specified Element using the chosen plotting engine and mode.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the element to plot (e.g., a component or bus).</p> required <code>mode</code> <code>(bar, line, area, heatmap)</code> <p>The type of plot to generate.</p> <code>'bar'</code> <code>variable_name</code> <code>str</code> <p>The variable to plot from the element's data.</p> <code>'flow_rate'</code> <code>heatmap_periods</code> <code>(YS, MS, W, D, h, '15min', min)</code> <p>The period for heatmap plotting.</p> <code>'YS'</code> <code>heatmap_steps_per_period</code> <code>(W, D, h, '15min', min)</code> <p>The steps per period for heatmap plotting.</p> <code>'W'</code> <code>colors</code> <code>str or List[str]</code> <p>The colors or colorscale to use for the plot.</p> <code>'viridis'</code> <code>engine</code> <code>(plotly, matplotlib)</code> <p>The plotting engine to use.</p> <code>'plotly'</code> <code>invert</code> <code>bool</code> <p>Whether to invert the input and output factors.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display the plot immediately. (This includes saving the plot to file when engine='plotly')</p> <code>True</code> <code>save</code> <code>bool</code> <p>Whether to save the plot to a file.</p> <code>False</code> <code>path</code> <code>Union[str, Path, Literal['auto']]</code> <p>The path to save the plot to. If 'auto', the plot is saved to an automatically named file.</p> <code>'auto'</code> <p>Returns:</p> Type Description <code>Union[Figure, Tuple[Figure, Axes]]</code> <p>The generated plot object, either a Plotly figure or a Matplotlib figure and axes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid engine or color configuration is provided for heatmap mode.</p>"},{"location":"api-reference/results/#flixOpt.results.CalculationResults.plot_storage","title":"plot_storage","text":"<pre><code>plot_storage(label: str, variable_name: str = 'flow_rate', mode: Literal['bar', 'line', 'area'] = 'area', colors: Union[str, List[str]] = 'viridis', invert: bool = True, show: bool = True, save: bool = False, path: Union[str, Path, Literal['auto']] = 'auto')\n</code></pre> <p>Plots the storage operation results for a specified Storage Element, including its charge state.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Storage to plot</p> required <code>variable_name</code> <code>str</code> <p>The variable to plot from the element's data.</p> <code>'flow_rate'</code> <code>mode</code> <code>(bar, line, area)</code> <p>The type of plot to generate.</p> <code>'bar'</code> <code>colors</code> <code>str or List[str]</code> <p>The colors or colorscale to use for the plot.</p> <code>'viridis'</code> <code>invert</code> <code>bool</code> <p>Whether to invert the input and output factors.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to display the plot immediately. (This includes saving the plot to file when engine='plotly')</p> <code>True</code> <code>save</code> <code>bool</code> <p>Whether to save the plot to a file.</p> <code>False</code> <code>path</code> <code>Union[str, Path, Literal['auto']]</code> <p>The path to save the plot to. If 'auto', the plot is saved to an automatically named file.</p> <code>'auto'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The generated Plotly figure object with the storage operation plot.</p>"},{"location":"api-reference/results/#flixOpt.results.CalculationResults.visualize_network","title":"visualize_network","text":"<pre><code>visualize_network(path: Union[bool, str, Path] = 'results/network.html', controls: Union[bool, List[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]] = True, show: bool = True) -&gt; Optional[pyvis.network.Network]\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, saving it as an interactive HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[bool, str, Path]</code> <p>Path to save the HTML visualization. If False, the visualization is created but not saved.</p> <code>'results/network.html'</code> <code>controls</code> <code>Union[bool, List[str]]</code> <p>UI controls to add to the visualization. True enables all available controls, or specify a list of controls.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to open the visualization in the web browser.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[Network]</code> <p>The Network instance representing the visualization, or None if pyvis is not installed.</p> Notes <p>This function requires pyvis. If not installed, the function prints a warning and returns None. Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/results/#flixOpt.results-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixOpt.results.extract_single_result","title":"extract_single_result","text":"<pre><code>extract_single_result(results_data: dict[str, Dict[str, Union[int, float, ndarray, dict]]], keys: List[str]) -&gt; Optional[Union[int, float, np.ndarray]]\n</code></pre> <p>Goes through a nested dictionary with the given keys. Returns the value if found. Else returns None</p>"},{"location":"api-reference/results/#flixOpt.results.extract_results","title":"extract_results","text":"<pre><code>extract_results(results_data: dict[str, Dict[str, Union[int, float, ndarray, dict]]], keys: List[str], keep_none: bool = False) -&gt; Dict[str, Union[int, float, np.ndarray]]\n</code></pre> <p>For each item in a dictionary, goes through its sub dictionaries. Returns the value if found. Else returns None. If specified, removes all None values</p>"},{"location":"api-reference/results/#flixOpt.results.flatten_dict","title":"flatten_dict","text":"<pre><code>flatten_dict(d, parent_key='', sep='__')\n</code></pre> <p>Recursively flattens a nested dictionary.</p> <p>Parameters:     d (dict): The dictionary to flatten.     parent_key (str): The base key for the current recursion level.     sep (str): The separator to use when concatenating keys.</p> <p>Returns:     dict: A flattened dictionary.</p>"},{"location":"api-reference/solvers/","title":"solvers","text":""},{"location":"api-reference/solvers/#flixOpt.solvers","title":"flixOpt.solvers","text":"<p>This module contains the solvers of the flixOpt framework, making them available to the end user in a compact way.</p>"},{"location":"api-reference/solvers/#flixOpt.solvers-classes","title":"Classes","text":""},{"location":"api-reference/solvers/#flixOpt.solvers.CbcSolver","title":"CbcSolver","text":"<pre><code>CbcSolver(mip_gap: float = 0.01, time_limit_seconds: int = 300, logfile_name: str = 'cbc.log', solver_output_to_console: bool = True)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for CBC. Also Look in class Solver for more details</p> <p>Attributes:     time_limit_seconds (int): Time limit for the solver. After this time, the solver takes the currently     best solution, ignoring the mip_gap.</p>"},{"location":"api-reference/solvers/#flixOpt.solvers.CplexSolver","title":"CplexSolver","text":"<pre><code>CplexSolver(mip_gap: float = 0.01, time_limit_seconds: int = 300, logfile_name: str = 'cplex.log', solver_output_to_console: bool = True)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for CPLEX. Also Look in class Solver for more details</p> <p>Attributes:     time_limit_seconds (int): Time limit for the solver. After this time, the solver takes the currently     best solution, ignoring the mip_gap.</p>"},{"location":"api-reference/solvers/#flixOpt.solvers.GlpkSolver","title":"GlpkSolver","text":"<pre><code>GlpkSolver(mip_gap: float = 0.01, logfile_name: str = 'glpk.log', solver_output_to_console: bool = True)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for Glpk. Also Look in class Solver for more details</p>"},{"location":"api-reference/solvers/#flixOpt.solvers.GurobiSolver","title":"GurobiSolver","text":"<pre><code>GurobiSolver(mip_gap: float = 0.01, time_limit_seconds: int = 300, logfile_name: str = 'gurobi.log', solver_output_to_console: bool = True)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for Gurobi. Also Look in class Solver for more details</p> <p>Attributes:     time_limit_seconds (int): Time limit for the solver. After this time, the solver takes the currently     best solution, ignoring the mip_gap.</p>"},{"location":"api-reference/solvers/#flixOpt.solvers.HighsSolver","title":"HighsSolver","text":"<pre><code>HighsSolver(mip_gap: float = 0.01, time_limit_seconds: int = 300, logfile_name: str = 'highs.log', solver_output_to_console: bool = True, threads: int = 4)\n</code></pre> <p>               Bases: <code>Solver</code></p> <p>Solver implementation for HIGHS. Also Look in class Solver for more details</p> <p>Attributes:     time_limit_seconds (int): Time limit for the solver. After this time, the solver takes the currently     best solution, ignoring the mip_gap.     threads (int): Number of threads to use for the solver.</p>"},{"location":"api-reference/solvers/#flixOpt.solvers.Solver","title":"Solver","text":"<pre><code>Solver(mip_gap: float, solver_output_to_console: bool, logfile_name: str)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for solvers.</p> <p>Attributes:     mip_gap (float): Solver's mip gap setting. The MIP gap describes the accepted (MILP) objective,         and the lower bound, which is the theoretically optimal solution (LP)     solver_output_to_console (bool): Whether to display solver output.     logfile_name (str): Filename for saving the solver log.     objective (Optional[float]): Objective value from the solution.     best_bound (Optional[float]): Best bound from the solver.     termination_message (Optional[str]): Solver's termination message.</p>"},{"location":"api-reference/structure/","title":"structure","text":""},{"location":"api-reference/structure/#flixOpt.structure","title":"flixOpt.structure","text":"<p>This module contains the core structure of the flixOpt framework. These classes are not directly used by the end user, but are used by other modules.</p>"},{"location":"api-reference/structure/#flixOpt.structure-classes","title":"Classes","text":""},{"location":"api-reference/structure/#flixOpt.structure.SystemModel","title":"SystemModel","text":"<pre><code>SystemModel(label: str, modeling_language: Literal['pyomo', 'cvxpy'], flow_system: FlowSystem, time_indices: Optional[Union[List[int], range]])\n</code></pre> <p>               Bases: <code>MathModel</code></p> <p>Hier kommen die ModellingLanguage-spezifischen Sachen rein</p>"},{"location":"api-reference/structure/#flixOpt.structure.SystemModel-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixOpt.structure.SystemModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: List[Variable]\n</code></pre> <p>Needed for Mother class</p>"},{"location":"api-reference/structure/#flixOpt.structure.SystemModel.equations","title":"equations  <code>property</code>","text":"<pre><code>equations: List[Equation]\n</code></pre> <p>Needed for Mother class</p>"},{"location":"api-reference/structure/#flixOpt.structure.SystemModel.inequations","title":"inequations  <code>property</code>","text":"<pre><code>inequations: List[Inequation]\n</code></pre> <p>Needed for Mother class</p>"},{"location":"api-reference/structure/#flixOpt.structure.SystemModel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixOpt.structure.SystemModel.solve","title":"solve","text":"<pre><code>solve(solver: Solver, excess_threshold: Union[int, float] = 0.1)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>Solver</code> <p>An Instance of the class Solver. Choose from flixOpt.solvers</p> required <code>excess_threshold</code> <code>float, positive!</code> <p>threshold for excess: If sum(Excess)&gt;excess_threshold a warning is raised, that an excess occurs</p> <code>0.1</code>"},{"location":"api-reference/structure/#flixOpt.structure.Interface","title":"Interface","text":"<p>This class is used to collect arguments about a Model.</p>"},{"location":"api-reference/structure/#flixOpt.structure.Interface-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixOpt.structure.Interface.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/structure/#flixOpt.structure.Interface.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/structure/#flixOpt.structure.Element","title":"Element","text":"<pre><code>Element(label: str, meta_data: Dict = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Basic Element of flixOpt</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>label of the element</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code>"},{"location":"api-reference/structure/#flixOpt.structure.Element-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixOpt.structure.Element.infos","title":"infos","text":"<pre><code>infos(use_numpy=True, use_element_label=False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> Parameters: <p>use_numpy bool:     Whether to convert NumPy arrays to lists. Defaults to True.     If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is.     If False, they are converted to lists. use_element_label bool:     Whether to use the element label instead of the infos of the element. Defaults to False.     Note that Elements used as keys in dictionaries are always converted to their labels.</p> <p>Returns:     Dict: A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/structure/#flixOpt.structure.Element.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> Parameters: <p>path : Union[str, pathlib.Path]     The path to the json file.</p>"},{"location":"api-reference/structure/#flixOpt.structure.ElementModel","title":"ElementModel","text":"<pre><code>ElementModel(element: Element, label: Optional[str] = None)\n</code></pre> <p>Interface to create the mathematical Models for Elements</p>"},{"location":"api-reference/structure/#flixOpt.structure-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixOpt.structure.create_equation","title":"create_equation","text":"<pre><code>create_equation(label: str, element_model: ElementModel, eq_type: Literal['eq', 'ineq'] = 'eq') -&gt; Union[Equation, Inequation]\n</code></pre> <p>Creates an Equation and adds it to the model of the Element</p>"},{"location":"api-reference/structure/#flixOpt.structure.create_variable","title":"create_variable","text":"<pre><code>create_variable(label: str, element_model: ElementModel, length: int, is_binary: bool = False, fixed_value: Optional[Numeric] = None, lower_bound: Optional[Numeric] = None, upper_bound: Optional[Numeric] = None, previous_values: Optional[Numeric] = None, avoid_use_of_variable_ts: bool = False) -&gt; VariableTS\n</code></pre> <p>Creates a VariableTS and adds it to the model of the Element</p>"},{"location":"api-reference/structure/#flixOpt.structure.copy_and_convert_datatypes","title":"copy_and_convert_datatypes","text":"<pre><code>copy_and_convert_datatypes(data: Any, use_numpy: bool = True, use_element_label: bool = False) -&gt; Any\n</code></pre> <p>Converts values in a nested data structure into JSON-compatible types while preserving or transforming numpy arrays and custom <code>Element</code> objects based on the specified options.</p> <p>The function handles various data types and transforms them into a consistent, readable format: - Primitive types (<code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>None</code>) are returned as-is. - Numpy scalars are converted to their corresponding Python scalar types. - Collections (<code>list</code>, <code>tuple</code>, <code>set</code>, <code>dict</code>) are recursively processed to ensure all elements are compatible. - Numpy arrays are preserved or converted to lists, depending on <code>use_numpy</code>. - Custom <code>Element</code> objects can be represented either by their <code>label</code> or their initialization parameters as a dictionary. - Timestamps (<code>datetime</code>) are converted to ISO 8601 strings.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data to process, which may be deeply nested and contain a mix of types.</p> required <code>use_numpy</code> <code>bool</code> <p>If <code>True</code>, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If <code>False</code>, they are converted to lists. Default is <code>True</code>.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>If <code>True</code>, <code>Element</code> objects are represented by their <code>label</code>. If <code>False</code>, they are converted into a dictionary based on their initialization parameters. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>A transformed version of the input data, containing only JSON-compatible types: - <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>None</code> - <code>list</code>, <code>dict</code> - <code>np.ndarray</code> (if <code>use_numpy=True</code>. This is NOT JSON-compatible)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the data cannot be converted to the specified types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; copy_and_convert_datatypes({'a': np.array([1, 2, 3]), 'b': Element(label='example')})\n{'a': array([1, 2, 3]), 'b': {'class': 'Element', 'label': 'example'}}\n</code></pre> <pre><code>&gt;&gt;&gt; copy_and_convert_datatypes({'a': np.array([1, 2, 3]), 'b': Element(label='example')}, use_numpy=False)\n{'a': [1, 2, 3], 'b': {'class': 'Element', 'label': 'example'}}\n</code></pre> Notes <ul> <li>The function gracefully handles unexpected types by issuing a warning and returning a deep copy of the data.</li> <li>Empty collections (lists, dictionaries) and default parameter values in <code>Element</code> objects are omitted from the output.</li> <li>Numpy arrays with non-numeric data types are automatically converted to lists.</li> </ul>"},{"location":"api-reference/structure/#flixOpt.structure.get_compact_representation","title":"get_compact_representation","text":"<pre><code>get_compact_representation(data: Any, array_threshold: int = 50, decimals: int = 2) -&gt; Dict\n</code></pre> <p>Generate a compact json serializable representation of deeply nested data. Numpy arrays are statistically described if they exceed a threshold and converted to lists.</p> <p>Args:     data (Any): The data to format and represent.     array_threshold (int): Maximum length of NumPy arrays to display. Longer arrays are statistically described.     decimals (int): Number of decimal places in which to describe the arrays.</p> <p>Returns:     Dict: A dictionary representation of the data</p>"},{"location":"api-reference/structure/#flixOpt.structure.get_str_representation","title":"get_str_representation","text":"<pre><code>get_str_representation(data: Any, array_threshold: int = 50, decimals: int = 2) -&gt; str\n</code></pre> <p>Generate a string representation of deeply nested data using <code>rich.print</code>. NumPy arrays are shortened to the specified length and converted to strings.</p> <p>Args:     data (Any): The data to format and represent.     array_threshold (int): Maximum length of NumPy arrays to display. Longer arrays are statistically described.     decimals (int): Number of decimal places in which to describe the arrays.</p> <p>Returns:     str: The formatted string representation of the data.</p>"},{"location":"api-reference/utils/","title":"utils","text":""},{"location":"api-reference/utils/#flixOpt.utils","title":"flixOpt.utils","text":"<p>This module contains several utility functions used throughout the flixOpt framework.</p>"},{"location":"api-reference/utils/#flixOpt.utils-functions","title":"Functions","text":""},{"location":"api-reference/utils/#flixOpt.utils.as_vector","title":"as_vector","text":"<pre><code>as_vector(value: Union[int, float, ndarray, List], length: int) -&gt; np.ndarray\n</code></pre> <p>Macht aus Skalar einen Vektor. Vektor bleibt Vektor. -&gt; Idee dahinter: Aufruf aus abgespeichertem Vektor schneller, als f\u00fcr jede i-te Gleichung zu Checken ob Vektor oder Skalar)</p> <p>Parameters:</p> Name Type Description Default <code>aValue</code> required <code>aLen</code> required"},{"location":"api-reference/utils/#flixOpt.utils.is_number","title":"is_number","text":"<pre><code>is_number(number_alias: Union[int, float, str])\n</code></pre> <p>Returns True is string is a number.</p>"},{"location":"api-reference/utils/#flixOpt.utils.label_is_valid","title":"label_is_valid","text":"<pre><code>label_is_valid(label: str) -&gt; bool\n</code></pre> <p>Function to make sure '__' is reserved for internal splitting of labels</p>"},{"location":"api-reference/utils/#flixOpt.utils.convert_numeric_lists_to_arrays","title":"convert_numeric_lists_to_arrays","text":"<pre><code>convert_numeric_lists_to_arrays(d: Union[Dict[str, Any], List[Any], tuple]) -&gt; Union[Dict[str, Any], List[Any], tuple]\n</code></pre> <p>Recursively converts all lists of numeric values in a nested dictionary to numpy arrays. Handles nested lists, tuples, and dictionaries. Does not alter the original dictionary.</p>"},{"location":"concepts-and-math/","title":"flixOpt Concepts &amp; Mathematical Description","text":"<p>flixOpt is built around a set of core concepts that work together to represent and optimize energy and material flow systems. This page provides a high-level overview of these concepts and how they interact.</p>"},{"location":"concepts-and-math/#core-concepts","title":"Core Concepts","text":""},{"location":"concepts-and-math/#flowsystem","title":"FlowSystem","text":"<p>The <code>FlowSystem</code> is the central organizing unit in flixOpt.  Every flixOpt model starts with creating a FlowSystem. It:</p> <ul> <li>Defines the timesteps for the optimization</li> <li>Contains and connects components, buses, and flows</li> <li>Manages the effects (objectives and constraints)</li> </ul>"},{"location":"concepts-and-math/#timesteps","title":"Timesteps","text":"<p>Time steps are defined as a sequence of discrete time steps \\(\\text{t}_i \\in \\mathcal{T} \\quad \\text{for} \\quad i \\in \\{1, 2, \\dots, \\text{n}\\}\\) (left-aligned in its timespan). From this sequence, the corresponding time intervals \\(\\Delta \\text{t}_i \\in \\Delta \\mathcal{T}\\) are derived as </p> \\[\\Delta \\text{t}_i = \\text{t}_{i+1} - \\text{t}_i \\quad \\text{for} \\quad i \\in \\{1, 2, \\dots, \\text{n}-1\\}\\] <p>The final time interval \\(\\Delta \\text{t}_\\text n\\) defaults to \\(\\Delta \\text{t}_\\text n = \\Delta \\text{t}_{\\text n-1}\\), but is of course customizable. Non-equidistant time steps are also supported.</p>"},{"location":"concepts-and-math/#buses","title":"Buses","text":"<p><code>Bus</code> objects represent nodes or connection points in a FlowSystem. They:</p> <ul> <li>Balance incoming and outgoing flows</li> <li>Can represent physical networks like heat, electricity, or gas </li> <li>Handle infeasible balances gently by allowing the balance to be closed in return for a big Penalty (optional)</li> </ul>"},{"location":"concepts-and-math/#flows","title":"Flows","text":"<p><code>Flow</code> objects represent the movement of energy or material between a Bus and a Component in a predefined direction.</p> <ul> <li>Have a <code>flow_rate</code>, which is the main optimization variable of a Flow</li> <li>Have a <code>size</code> which defines how much energy or material can be moved (fixed or part of an investment decision)</li> <li>Have constraints to limit the flow-rate (min/max, total flow hours, on/off etc.)</li> <li>Can have fixed profiles (for demands or renewable generation)</li> <li>Can have Effects associated by their use (operation, investment, on/off, ...)</li> </ul>"},{"location":"concepts-and-math/#components","title":"Components","text":"<p><code>Component</code> objects usually represent physical entities in your system that interact with <code>Flows</code>. They include:</p> <ul> <li><code>LinearConverters</code> - Converts input flows to output flows with (piecewise) linear relationships</li> <li><code>Storages</code> - Stores energy or material over time</li> <li><code>Sources</code> / <code>Sinks</code> / <code>SourceAndSinks</code> - Produce or consume flows. They are usually used to model external demands or supplies.</li> <li><code>Transmissions</code> - Moves flows between locations with possible losses</li> <li>Specialized <code>LinearConverters</code> like <code>Boilers</code>, <code>HeatPumps</code>, <code>CHPs</code>, etc. These simplify the usage of the <code>LinearConverter</code> class and can also be used as blueprint on how to define custom classes or parameterize existing ones.</li> </ul>"},{"location":"concepts-and-math/#effects","title":"Effects","text":"<p><code>Effect</code> objects represent impacts or metrics related to your system, such as:</p> <ul> <li>Costs (investment, operation)</li> <li>Emissions (CO\u2082, NOx, etc.)</li> <li>Resource consumption</li> </ul> <p>These can be freely defined and crosslink to each other (<code>CO\u2082</code> \u2500\u2500[specific CO\u2082-costs]\u2500\u2192 <code>Costs</code>). One effect is designated as the optimization objective (typically Costs), while others can have constraints. This effect can incorporate several other effects, which woul result in a weighted objective from multiple effects.</p>"},{"location":"concepts-and-math/#calculation-modes","title":"Calculation Modes","text":"<p>flixOpt offers different calculation approaches:</p> <ul> <li><code>FullCalculation</code> - Solves the entire problem at once</li> <li><code>SegmentedCalculation</code> - Solves the problem in segments (with optioinal overlap), improving performance for large problems</li> <li><code>AggregatedCalculation</code> - Uses typical periods to reduce computational requirements</li> </ul>"},{"location":"concepts-and-math/#how-these-concepts-work-together","title":"How These Concepts Work Together","text":"<ol> <li>You create a <code>FlowSystem</code> with a specified time series</li> <li>You add elements to the FLowSystem:<ul> <li><code>Bus</code> objects as connection points</li> <li><code>Component</code> objects like Boilers, Storages, etc.. They include <code>Flow</code> which define the connection to a Bus.</li> <li><code>Effect</code> objects to represent costs, emissions, etc. 3.You choose a calculation mode and solver 4.flixOpt converts your model into a mathematical optimization problem 5.The solver finds the optimal solution 6.You analyze the results with built-in or external tools</li> </ul> </li> </ol>"},{"location":"concepts-and-math/#advanced-usage","title":"Advanced Usage","text":"<p>flixOpt uses linopy to model the mathematical optimization problem. Any model created with flixOpt can be extended or modified using the great linopy API. This allows to adjust your model to very specific requirements without loosing the convenience of flixOpt.</p>"},{"location":"concepts-and-math/#architechture-outdated","title":"Architechture (outdated)","text":""},{"location":"concepts-and-math/Mathematical%20Description/","title":"Mathematical Notation","text":""},{"location":"concepts-and-math/Mathematical%20Description/#naming-conventions","title":"Naming Conventions","text":"<p>flixOpt uses the following naming conventions:</p> <ul> <li>All optimization variables are denoted by italic letters (e.g., \\(x\\), \\(y\\), \\(z\\))</li> <li>All parameters and constants are denoted by non italic small letters (e.g., \\(\\text{a}\\), \\(\\text{b}\\), \\(\\text{c}\\))</li> <li>All Sets are denoted by greek capital letters (e.g., \\(\\mathcal{F}\\), \\(\\mathcal{E}\\))</li> <li>All units of a set are denoted by greek small letters (e.g., \\(\\mathcal{f}\\), \\(\\mathcal{e}\\))</li> <li>The letter \\(i\\) is used to denote an index (e.g., \\(i=1,\\dots,\\text n\\))</li> <li>All time steps are denoted by the letter \\(\\text{t}\\) (e.g., \\(\\text{t}_0\\), \\(\\text{t}_1\\), \\(\\text{t}_i\\))</li> </ul>"},{"location":"concepts-and-math/Mathematical%20Description/#buses","title":"Buses","text":"<p>The balance equation for a bus is:</p> \\[ \\label{eq:bus_balance}   \\sum_{f_\\text{in} \\in \\mathcal{F}_\\text{in}} p_{f_\\text{in}}(\\text{t}_i) =   \\sum_{f_\\text{out} \\in \\mathcal{F}_\\text{out}} p_{f_\\text{out}}(\\text{t}_i) \\] <p>Optionally, a Bus can have a <code>excess_penalty_per_flow_hour</code> parameter, which allows to penalize the balance for missing or excess flow-rates. This is usefull as it handles a possible ifeasiblity gently.</p> <p>This changes the balance to</p> \\[ \\label{eq:bus_balance-excess}   \\sum_{f_\\text{in} \\in \\mathcal{F}_\\text{in}} p_{f_ \\text{in}}(\\text{t}_i) + \\phi_\\text{in}(\\text{t}_i) =   \\sum_{f_\\text{out} \\in \\mathcal{F}_\\text{out}} p_{f_\\text{out}}(\\text{t}_i) + \\phi_\\text{out}(\\text{t}_i) \\] <p>The penalty term is defined as</p> \\[ \\label{eq:bus_penalty}   s_{b \\rightarrow \\Phi}(\\text{t}_i) =       \\text a_{b \\rightarrow \\Phi}(\\text{t}_i) \\cdot \\Delta \\text{t}_i       \\cdot [ \\phi_\\text{in}(\\text{t}_i) + \\phi_\\text{out}(\\text{t}_i) ] \\] <p>With:</p> <ul> <li>\\(\\mathcal{F}_\\text{in}\\) and \\(\\mathcal{F}_\\text{out}\\) being the set of all incoming and outgoing flows</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) and \\(p_{f_\\text{out}}(\\text{t}_i)\\) being the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> <li>\\(\\phi_\\text{in}(\\text{t}_i)\\) and \\(\\phi_\\text{out}(\\text{t}_i)\\) being the missing or excess flow-rate at time \\(\\text{t}_i\\), respectively</li> <li>\\(\\text{t}_i\\) being the time step</li> <li>\\(s_{b \\rightarrow \\Phi}(\\text{t}_i)\\) being the penalty term</li> <li>\\(\\text a_{b \\rightarrow \\Phi}(\\text{t}_i)\\) being the penalty coefficient (<code>excess_penalty_per_flow_hour</code>)</li> </ul>"},{"location":"concepts-and-math/Mathematical%20Description/#flows","title":"Flows","text":"<p>The flow-rate is the main optimization variable of the Flow. It's limited by the size of the Flow and relative bounds \\eqref{eq:flow_rate}.</p> \\[ \\label{eq:flow_rate}     \\text P \\cdot \\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i})     \\leq p(\\text{t}_{i}) \\leq     \\text P \\cdot \\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i}) \\] <p>With:</p> <ul> <li>\\(\\text P\\) being the size of the Flow</li> <li>\\(p(\\text{t}_{i})\\) being the flow-rate at time \\(\\text{t}_{i}\\)</li> <li>\\(\\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i})\\) being the relative lower bound (typically 0)</li> <li>\\(\\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i})\\) being the relative upper bound (typically 1)</li> </ul> <p>With \\(\\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i}) = 0\\) and \\(\\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i}) = 1\\), equation \\eqref{eq:flow_rate} simplifies to</p> \\[     0 \\leq p(\\text{t}_{i}) \\leq \\text P \\] <p>This mathematical Formulation can be extended or changed when using OnOffParameters to define the On/Off state of the Flow, or InvestParameters, which changes the size of the Flow from a constant to an optimization variable.</p>"},{"location":"concepts-and-math/Mathematical%20Description/#linearconverters","title":"LinearConverters","text":"<p><code>LinearConverters</code> define a ratio between incoming and outgoing Flows.</p> \\[ \\label{eq:Linear-Transformer-Ratio}     \\sum_{f_{\\text{in}} \\in \\mathcal F_{in}} \\text a_{f_{\\text{in}}}(\\text{t}_i) \\cdot p_{f_\\text{in}}(\\text{t}_i) = \\sum_{f_{\\text{out}} \\in \\mathcal F_{out}}  \\text b_{f_\\text{out}}(\\text{t}_i) \\cdot p_{f_\\text{out}}(\\text{t}_i) \\] <p>With:</p> <ul> <li>\\(\\mathcal F_{in}\\) and \\(\\mathcal F_{out}\\) being the set of all incoming and outgoing flows</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) and \\(p_{f_\\text{out}}(\\text{t}_i)\\) being the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> <li>\\(\\text a_{f_\\text{in}}(\\text{t}_i)\\) and \\(\\text b_{f_\\text{out}}(\\text{t}_i)\\) being the ratio of the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> </ul> <p>With one incoming Flow and one outgoing Flow, this can be simplified to: </p> \\[ \\label{eq:Linear-Transformer-Ratio-simple}     \\text a(\\text{t}_i) \\cdot p_{f_\\text{in}}(\\text{t}_i) = p_{f_\\text{out}}(\\text{t}_i) \\] <p>where \\(\\text a\\) can be interpreted as the conversion efficiency of the LinearTransformer.</p>"},{"location":"concepts-and-math/Mathematical%20Description/#piecewise-concersion-factors","title":"Piecewise Concersion factors","text":"<p>The conversion efficiency can be defined as a piecewise function.</p>"},{"location":"concepts-and-math/Mathematical%20Description/#effects","title":"Effects","text":""},{"location":"concepts-and-math/Mathematical%20Description/#features","title":"Features","text":""},{"location":"concepts-and-math/Mathematical%20Description/#investparameters","title":"InvestParameters","text":""},{"location":"concepts-and-math/Mathematical%20Description/#onoffparameters","title":"OnOffParameters","text":""},{"location":"concepts-and-math/Mathematical%20Description/#calculation-modes","title":"Calculation Modes","text":""},{"location":"examples/00-Minimal%20Example/","title":"Minimal Example","text":"<pre><code>\"\"\"\nThis script shows how to use the flixOpt framework to model a super minimalistic energy system.\n\"\"\"\n\nimport numpy as np\nfrom rich.pretty import pprint\n\nimport flixOpt as fx\n\nif __name__ == '__main__':\n    # --- Define Thermal Load Profile ---\n    # Load profile (e.g., kW) for heating demand over time\n    thermal_load_profile = np.array([30, 0, 20])\n    datetime_series = fx.create_datetime_array('2020-01-01', 3, 'h')\n\n    # --- Define Energy Buses ---\n    # These represent the different energy carriers in the system\n    electricity_bus = fx.Bus('Electricity')\n    heat_bus = fx.Bus('District Heating')\n    fuel_bus = fx.Bus('Natural Gas')\n\n    # --- Define Objective Effect (Cost) ---\n    # Cost effect representing the optimization objective (minimizing costs)\n    cost_effect = fx.Effect('costs', '\u20ac', 'Cost', is_standard=True, is_objective=True)\n\n    # --- Define Flow System Components ---\n    # Boiler component with thermal output (heat) and fuel input (gas)\n    boiler = fx.linear_converters.Boiler(\n        'Boiler',\n        eta=0.5,\n        Q_th=fx.Flow(label='Thermal Output', bus=heat_bus, size=50),\n        Q_fu=fx.Flow(label='Fuel Input', bus=fuel_bus),\n    )\n\n    # Heat load component with a fixed thermal demand profile\n    heat_load = fx.Sink(\n        'Heat Demand',\n        sink=fx.Flow(label='Thermal Load', bus=heat_bus, size=1, fixed_relative_profile=thermal_load_profile),\n    )\n\n    # Gas source component with cost-effect per flow hour\n    gas_source = fx.Source(\n        'Natural Gas Tariff',\n        source=fx.Flow(label='Gas Flow', bus=fuel_bus, size=1000, effects_per_flow_hour=0.04),  # 0.04 \u20ac/kWh\n    )\n\n    # --- Build the Flow System ---\n    # Add all components and effects to the system\n    flow_system = fx.FlowSystem(datetime_series)\n    flow_system.add_elements(cost_effect, boiler, heat_load, gas_source)\n\n    # --- Define and Run Calculation ---\n    calculation = fx.FullCalculation('Simulation1', flow_system)\n    calculation.do_modeling()\n\n    # --- Solve the Calculation and Save Results ---\n    calculation.solve(fx.solvers.HighsSolver(), save_results=True)\n\n    # --- Load and Analyze Results ---\n    # Load results and plot the operation of the District Heating Bus\n    results = fx.results.CalculationResults(calculation.name, folder='results')\n    results.plot_operation('District Heating', 'area')\n\n    # Print results to the console. Check Results in file or perform more plotting\n    pprint(calculation.results())\n    pprint('Look into .yaml and .json file for results')\n    pprint(calculation.system_model.main_results)\n</code></pre>"},{"location":"examples/01-Basic%20Example/","title":"Simple example","text":"<pre><code>\"\"\"\nTHis script shows how to use the flixOpt framework to model a simple energy system.\n\"\"\"\n\nimport numpy as np\nfrom rich.pretty import pprint  # Used for pretty printing\n\nimport flixOpt as fx\n\nif __name__ == '__main__':\n    # --- Create Time Series Data ---\n    # Heat demand profile (e.g., kW) over time and corresponding power prices\n    heat_demand_per_h = np.array([30, 0, 90, 110, 110, 20, 20, 20, 20])\n    power_prices = 1 / 1000 * np.array([80, 80, 80, 80, 80, 80, 80, 80, 80])\n\n    # Create datetime array starting from '2020-01-01' for the given time period\n    time_series = fx.create_datetime_array('2020-01-01', len(heat_demand_per_h))\n\n    # --- Define Energy Buses ---\n    # These represent nodes, where the used medias are balanced (electricity, heat, and gas)\n    Strom, Fernwaerme, Gas = fx.Bus(label='Strom'), fx.Bus(label='Fernw\u00e4rme'), fx.Bus(label='Gas')\n\n    # --- Define Effects (Objective and CO2 Emissions) ---\n    # Cost effect: used as the optimization objective --&gt; minimizing costs\n    costs = fx.Effect(\n        label='costs',\n        unit='\u20ac',\n        description='Kosten',\n        is_standard=True,  # standard effect: no explicit value needed for costs\n        is_objective=True,  # Minimizing costs as the optimization objective\n    )\n\n    # CO2 emissions effect with an associated cost impact\n    CO2 = fx.Effect(\n        label='CO2',\n        unit='kg',\n        description='CO2_e-Emissionen',\n        specific_share_to_other_effects_operation={costs: 0.2},\n        maximum_operation_per_hour=1000,  # Max CO2 emissions per hour\n    )\n\n    # --- Define Flow System Components ---\n    # Boiler: Converts fuel (gas) into thermal energy (heat)\n    boiler = fx.linear_converters.Boiler(\n        label='Boiler',\n        eta=0.5,\n        Q_th=fx.Flow(label='Q_th', bus=Fernwaerme, size=50, relative_minimum=0.1, relative_maximum=1),\n        Q_fu=fx.Flow(label='Q_fu', bus=Gas),\n    )\n\n    # Combined Heat and Power (CHP): Generates both electricity and heat from fuel\n    chp = fx.linear_converters.CHP(\n        label='CHP',\n        eta_th=0.5,\n        eta_el=0.4,\n        P_el=fx.Flow('P_el', bus=Strom, size=60, relative_minimum=5 / 60),\n        Q_th=fx.Flow('Q_th', bus=Fernwaerme),\n        Q_fu=fx.Flow('Q_fu', bus=Gas),\n    )\n\n    # Storage: Energy storage system with charging and discharging capabilities\n    storage = fx.Storage(\n        label='Storage',\n        charging=fx.Flow('Q_th_load', bus=Fernwaerme, size=1000),\n        discharging=fx.Flow('Q_th_unload', bus=Fernwaerme, size=1000),\n        capacity_in_flow_hours=fx.InvestParameters(fix_effects=20, fixed_size=30, optional=False),\n        initial_charge_state=0,  # Initial storage state: empty\n        relative_maximum_charge_state=1 / 100 * np.array([80, 70, 80, 80, 80, 80, 80, 80, 80, 80]),\n        eta_charge=0.9,\n        eta_discharge=1,  # Efficiency factors for charging/discharging\n        relative_loss_per_hour=0.08,  # 8% loss per hour. Absolute loss depends on current charge state\n        prevent_simultaneous_charge_and_discharge=True,  # Prevent charging and discharging at the same time\n    )\n\n    # Heat Demand Sink: Represents a fixed heat demand profile\n    heat_sink = fx.Sink(\n        label='Heat Demand',\n        sink=fx.Flow(label='Q_th_Last', bus=Fernwaerme, size=1, fixed_relative_profile=heat_demand_per_h),\n    )\n\n    # Gas Source: Gas tariff source with associated costs and CO2 emissions\n    gas_source = fx.Source(\n        label='Gastarif',\n        source=fx.Flow(label='Q_Gas', bus=Gas, size=1000, effects_per_flow_hour={costs: 0.04, CO2: 0.3}),\n    )\n\n    # Power Sink: Represents the export of electricity to the grid\n    power_sink = fx.Sink(\n        label='Einspeisung', sink=fx.Flow(label='P_el', bus=Strom, effects_per_flow_hour=-1 * power_prices)\n    )\n\n    # --- Build the Flow System ---\n    # Create the flow system and add all defined components and effects\n    flow_system = fx.FlowSystem(time_series=time_series)\n    flow_system.add_elements(costs, CO2, boiler, storage, chp, heat_sink, gas_source, power_sink)\n\n    # Visualize the flow system for validation purposes\n    flow_system.visualize_network()\n\n    # --- Define and Run Calculation ---\n    # Create a calculation object to model the Flow System\n    calculation = fx.FullCalculation(name='Sim1', flow_system=flow_system)\n    calculation.do_modeling()  # Translate the model to a solvable form, creating equations and Variables\n\n    # --- Solve the Calculation and Save Results ---\n    calculation.solve(fx.solvers.HighsSolver(), save_results=True)\n\n    # --- Load and Analyze Results ---\n    # Load the results and plot the operation of the District Heating Bus\n    results = fx.results.CalculationResults(calculation.name, folder='results')\n    results.plot_operation('Fernw\u00e4rme', 'area')\n    results.plot_storage('Storage')\n    results.plot_operation('Fernw\u00e4rme', 'bar')\n    results.plot_operation('Fernw\u00e4rme', 'line')\n    results.plot_operation('CHP__Q_th', 'line')\n    results.plot_operation('CHP__Q_th', 'heatmap')\n\n    # Convert the results for the storage component to a dataframe and display\n    results.to_dataframe('Storage')\n    pprint(results.all_results)\n</code></pre>"},{"location":"examples/02-Complex%20Example/","title":"Complex example","text":"<p>This saves the results of a calculation to file and reloads them to analyze the results</p>"},{"location":"examples/02-Complex%20Example/#build-the-model","title":"Build the Model","text":"<pre><code>\"\"\"\nThis script shows how to use the flixOpt framework to model a more complex energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom rich.pretty import pprint  # Used for pretty printing\n\nimport flixOpt as fx\n\nif __name__ == '__main__':\n    # --- Experiment Options ---\n    # Configure options for testing various parameters and behaviors\n    check_penalty = False\n    excess_penalty = 1e5\n    use_chp_with_segments = False\n    time_indices = None  # Define specific time steps for custom calculations, or use the entire series\n\n    # --- Define Demand and Price Profiles ---\n    # Input data for electricity and heat demands, as well as electricity price\n    electricity_demand = np.array([70, 80, 90, 90, 90, 90, 90, 90, 90])\n    heat_demand = (\n        np.array([30, 0, 90, 110, 2000, 20, 20, 20, 20])\n        if check_penalty\n        else np.array([30, 0, 90, 110, 110, 20, 20, 20, 20])\n    )\n    electricity_price = np.array([40, 40, 40, 40, 40, 40, 40, 40, 40])\n\n    time_series = fx.create_datetime_array('2020-01-01', len(heat_demand), freq='h')\n\n    # --- Define Energy Buses ---\n    # Represent different energy carriers (electricity, heat, gas) in the system\n    Strom = fx.Bus('Strom', excess_penalty_per_flow_hour=excess_penalty)\n    Fernwaerme = fx.Bus('Fernw\u00e4rme', excess_penalty_per_flow_hour=excess_penalty)\n    Gas = fx.Bus('Gas', excess_penalty_per_flow_hour=excess_penalty)\n\n    # --- Define Effects ---\n    # Specify effects related to costs, CO2 emissions, and primary energy consumption\n    Costs = fx.Effect('costs', '\u20ac', 'Kosten', is_standard=True, is_objective=True)\n    CO2 = fx.Effect('CO2', 'kg', 'CO2_e-Emissionen', specific_share_to_other_effects_operation={Costs: 0.2})\n    PE = fx.Effect('PE', 'kWh_PE', 'Prim\u00e4renergie', maximum_total=3.5e3)\n\n    # --- Define Components ---\n    # 1. Define Boiler Component\n    # A gas boiler that converts fuel into thermal output, with investment and on-off parameters\n    Gaskessel = fx.linear_converters.Boiler(\n        'Kessel',\n        eta=0.5,  # Efficiency ratio\n        on_off_parameters=fx.OnOffParameters(effects_per_running_hour={Costs: 0, CO2: 1000}),  # CO2 emissions per hour\n        Q_th=fx.Flow(\n            label='Q_th',  # Thermal output\n            bus=Fernwaerme,  # Linked bus\n            size=fx.InvestParameters(\n                fix_effects=1000,  # Fixed investment costs\n                fixed_size=50,  # Fixed size\n                optional=False,  # Forced investment\n                specific_effects={Costs: 10, PE: 2},  # Specific costs\n            ),\n            load_factor_max=1.0,  # Maximum load factor (50 kW)\n            load_factor_min=0.1,  # Minimum load factor (5 kW)\n            relative_minimum=5 / 50,  # Minimum part load\n            relative_maximum=1,  # Maximum part load\n            previous_flow_rate=50,  # Previous flow rate\n            flow_hours_total_max=1e6,  # Total energy flow limit\n            on_off_parameters=fx.OnOffParameters(\n                on_hours_total_min=0,  # Minimum operating hours\n                on_hours_total_max=1000,  # Maximum operating hours\n                consecutive_on_hours_max=10,  # Max consecutive operating hours\n                consecutive_on_hours_min=np.array(\n                    [1, 1, 1, 1, 1, 2, 2, 2, 2]\n                ),  # min consecutive operation hoursconsecutive_off_hours_max=10,  # Max consecutive off hours\n                effects_per_switch_on=0.01,  # Cost per switch-on\n                switch_on_total_max=1000,  # Max number of starts\n            ),\n        ),\n        Q_fu=fx.Flow(label='Q_fu', bus=Gas, size=200),\n    )\n\n    # 2. Define CHP Unit\n    # Combined Heat and Power unit that generates both electricity and heat from fuel\n    bhkw = fx.linear_converters.CHP(\n        'BHKW2',\n        eta_th=0.5,\n        eta_el=0.4,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=0.01),\n        P_el=fx.Flow('P_el', bus=Strom, size=60, relative_minimum=5 / 60),\n        Q_th=fx.Flow('Q_th', bus=Fernwaerme, size=1e3),\n        Q_fu=fx.Flow('Q_fu', bus=Gas, size=1e3, previous_flow_rate=20),  # The CHP was ON previously\n    )\n\n    # 3. Define CHP with Linear Segments\n    # This CHP unit uses linear segments for more dynamic behavior over time\n    P_el = fx.Flow('P_el', bus=Strom, size=60, previous_flow_rate=20)\n    Q_th = fx.Flow('Q_th', bus=Fernwaerme)\n    Q_fu = fx.Flow('Q_fu', bus=Gas)\n    segmented_conversion_factors = {\n        P_el: [(5, 30), (40, 60)],  # Similar to eta_th, each factor here can be an array\n        Q_th: [(6, 35), (45, 100)],\n        Q_fu: [(12, 70), (90, 200)],\n    }\n\n    bhkw_2 = fx.LinearConverter(\n        'BHKW2',\n        inputs=[Q_fu],\n        outputs=[P_el, Q_th],\n        segmented_conversion_factors=segmented_conversion_factors,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=0.01),\n    )\n\n    # 4. Define Storage Component\n    # Storage with variable size and segmented investment effects\n    segmented_investment_effects = (\n        [(5, 25), (25, 100)],  # Investment size\n        {\n            Costs: [(50, 250), (250, 800)],  # Investment costs\n            PE: [(5, 25), (25, 100)],  # Primary energy costs\n        },\n    )\n\n    speicher = fx.Storage(\n        'Speicher',\n        charging=fx.Flow('Q_th_load', bus=Fernwaerme, size=1e4),\n        discharging=fx.Flow('Q_th_unload', bus=Fernwaerme, size=1e4),\n        capacity_in_flow_hours=fx.InvestParameters(\n            effects_in_segments=segmented_investment_effects,  # Investment effects\n            optional=False,  # Forced investment\n            minimum_size=0,\n            maximum_size=1000,  # Optimizing between 0 and 1000 kWh\n        ),\n        initial_charge_state=0,  # Initial charge state\n        maximal_final_charge_state=10,  # Maximum final charge state\n        eta_charge=0.9,\n        eta_discharge=1,  # Charge/discharge efficiency\n        relative_loss_per_hour=0.08,  # Energy loss per hour, relative to current charge state\n        prevent_simultaneous_charge_and_discharge=True,  # Prevent simultaneous charge/discharge\n    )\n\n    # 5. Define Sinks and Sources\n    # 5.a) Heat demand profile\n    Waermelast = fx.Sink(\n        'W\u00e4rmelast',\n        sink=fx.Flow(\n            'Q_th_Last',  # Heat sink\n            bus=Fernwaerme,  # Linked bus\n            size=1,\n            fixed_relative_profile=heat_demand,  # Fixed demand profile\n        ),\n    )\n\n    # 5.b) Gas tariff\n    Gasbezug = fx.Source(\n        'Gastarif',\n        source=fx.Flow(\n            'Q_Gas',\n            bus=Gas,  # Gas source\n            size=1000,  # Nominal size\n            effects_per_flow_hour={Costs: 0.04, CO2: 0.3},\n        ),\n    )\n\n    # 5.c) Feed-in of electricity\n    Stromverkauf = fx.Sink(\n        'Einspeisung',\n        sink=fx.Flow(\n            'P_el',\n            bus=Strom,  # Feed-in tariff for electricity\n            effects_per_flow_hour=-1 * electricity_price,  # Negative price for feed-in\n        ),\n    )\n\n    # --- Build FlowSystem ---\n    # Select components to be included in the final system model\n    flow_system = fx.FlowSystem(time_series, last_time_step_hours=None)  # Create FlowSystem\n\n    flow_system.add_elements(Costs, CO2, PE, Gaskessel, Waermelast, Gasbezug, Stromverkauf, speicher)\n    flow_system.add_elements(bhkw_2) if use_chp_with_segments else flow_system.add_components(bhkw)\n\n    pprint(flow_system)  # Get a string representation of the FlowSystem\n\n    # --- Solve FlowSystem ---\n    calculation = fx.FullCalculation('Sim1', flow_system, 'pyomo', time_indices)\n    calculation.do_modeling()\n\n    # Show variables as str (else, you can find them in the results.yaml file\n    pprint(calculation.system_model.description_of_constraints())\n    pprint(calculation.system_model.description_of_variables())\n\n    calculation.solve(\n        fx.solvers.HighsSolver(\n            mip_gap=0.005, time_limit_seconds=30\n        ),  # Specify which solver you want to use and specify parameters\n        save_results='results',  # If and where to save results\n    )\n\n    # --- Results ---\n    # You can analyze results directly. But it's better to save them to a file and start from there,\n    # letting you continue at any time\n    # See complex_example_evaluation.py\n    used_time_series = time_series[time_indices] if time_indices else time_series\n    # Analyze results directly\n    fig = fx.plotting.with_plotly(\n        data=pd.DataFrame(Gaskessel.Q_th.model.flow_rate.result, index=used_time_series), mode='bar', show=True\n    )\n</code></pre>"},{"location":"examples/02-Complex%20Example/#load-the-results-from-file","title":"Load the Results from file","text":"<pre><code>\"\"\"\nThis script shows how load results of a prior calcualtion and how to analyze them.\n\"\"\"\n\nimport pandas as pd\nimport plotly.offline\n\nimport flixOpt as fx\n\nif __name__ == '__main__':\n    # --- Load Results ---\n    try:\n        results = fx.results.CalculationResults('Sim1', folder='results')\n    except FileNotFoundError as e:\n        raise FileNotFoundError(\n            f\"Results file not found in the specified directory ('results'). \"\n            f\"Please ensure that the file is generated by running 'complex_example.py'. \"\n            f'Original error: {e}'\n        ) from e\n\n    # --- Basic overview ---\n    results.visualize_network()\n    results.plot_operation('Fernw\u00e4rme')\n    results.plot_operation('Fernw\u00e4rme', 'bar')\n    results.plot_operation('Fernw\u00e4rme', 'bar', engine='matplotlib')\n\n    # --- Detailed Plots ---\n    # In depth plot for individual flow rates ('__' is used as the delimiter between Component and Flow\n    results.plot_operation('W\u00e4rmelast__Q_th_Last', 'heatmap')\n    figs = []\n    for flow_label in results.flow_results():\n        if flow_label.startswith('BHKW2'):\n            fig = results.plot_operation(flow_label, 'heatmap', heatmap_steps_per_period='h', heatmap_periods='D')\n\n    # --- Plotting internal variables manually ---\n    on_data = pd.DataFrame(\n        {\n            'BHKW2 On': results.component_results['BHKW2'].variables['Q_th']['OnOff']['on'],\n            'Kessel On': results.component_results['Kessel'].variables['Q_th']['OnOff']['on'],\n        },\n        index=results.time,\n    )\n    fig = fx.plotting.with_plotly(on_data, 'line')\n    fig.write_html('results/on.html')  # Writing to file\n\n    fig = fx.plotting.with_plotly(on_data, 'bar')\n    fig.update_layout(barmode='group', bargap=0.1)  # Applying custom layout\n    plotly.offline.plot(fig)\n</code></pre>"},{"location":"examples/03-Calculation%20Modes/","title":"Calculation Mode comparison","text":"<p>Note: This example relies on time series data. You can find it in the <code>examples</code> folder of the flixOpt repository. <pre><code>\"\"\"\nThis script demonstrates how to use the different calcualtion types in the flixOPt framework\nto model the same energy system. THe Results will be compared to each other.\n\"\"\"\n\nimport pathlib\nfrom typing import Dict, List, Union\n\nimport numpy as np\nimport pandas as pd\nfrom rich.pretty import pprint  # Used for pretty printing\n\nimport flixOpt as fx\n\nif __name__ == '__main__':\n    # Calculation Types\n    full, segmented, aggregated = True, True, True\n\n    # Segmented Properties\n    segment_length, overlap_length = 96, 1\n\n    # Aggregated Properties\n    aggregation_parameters = fx.AggregationParameters(\n        hours_per_period=6,\n        nr_of_periods=4,\n        fix_storage_flows=True,\n        aggregate_data_and_fix_non_binary_vars=True,\n        percentage_of_period_freedom=0,\n        penalty_of_period_freedom=0,\n    )\n    keep_extreme_periods = True\n\n    # Data Import\n    data_import = pd.read_csv(pathlib.Path('Zeitreihen2020.csv'), index_col=0).sort_index()\n    filtered_data = data_import['2020-01-01':'2020-01-2 23:45:00']\n    # filtered_data = data_import[0:500]  # Alternatively filter by index\n\n    filtered_data.index = pd.to_datetime(filtered_data.index)\n    datetime_series = np.array(filtered_data.index).astype('datetime64')\n\n    # Access specific columns and convert to 1D-numpy array\n    electricity_demand = filtered_data['P_Netz/MW'].to_numpy()\n    heat_demand = filtered_data['Q_Netz/MW'].to_numpy()\n    electricity_price = filtered_data['Strompr.\u20ac/MWh'].to_numpy()\n    gas_price = filtered_data['Gaspr.\u20ac/MWh'].to_numpy()\n\n    # TimeSeriesData objects\n    TS_heat_demand = fx.TimeSeriesData(heat_demand)\n    TS_electricity_demand = fx.TimeSeriesData(electricity_demand, agg_weight=0.7)\n    TS_electricity_price_sell = fx.TimeSeriesData(-(electricity_demand - 0.5), agg_group='p_el')\n    TS_electricity_price_buy = fx.TimeSeriesData(electricity_price + 0.5, agg_group='p_el')\n\n    # Bus Definitions\n    excess_penalty = 1e5  # or set to None if not needed\n    Strom = fx.Bus('Strom', excess_penalty_per_flow_hour=excess_penalty)\n    Fernwaerme = fx.Bus('Fernw\u00e4rme', excess_penalty_per_flow_hour=excess_penalty)\n    Gas = fx.Bus('Gas', excess_penalty_per_flow_hour=excess_penalty)\n    Kohle = fx.Bus('Kohle', excess_penalty_per_flow_hour=excess_penalty)\n\n    # Effects\n    costs = fx.Effect('costs', '\u20ac', 'Kosten', is_standard=True, is_objective=True)\n    CO2 = fx.Effect('CO2', 'kg', 'CO2_e-Emissionen')\n    PE = fx.Effect('PE', 'kWh_PE', 'Prim\u00e4renergie')\n\n    # Component Definitions\n\n    # 1. Boiler\n    a_gaskessel = fx.linear_converters.Boiler(\n        'Kessel',\n        eta=0.85,\n        Q_th=fx.Flow(label='Q_th', bus=Fernwaerme),\n        Q_fu=fx.Flow(\n            label='Q_fu',\n            bus=Gas,\n            size=95,\n            relative_minimum=12 / 95,\n            previous_flow_rate=20,\n            on_off_parameters=fx.OnOffParameters(effects_per_switch_on=1000),\n        ),\n    )\n\n    # 2. CHP\n    a_kwk = fx.linear_converters.CHP(\n        'BHKW2',\n        eta_th=0.58,\n        eta_el=0.22,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=24000),\n        P_el=fx.Flow('P_el', bus=Strom, size=200),\n        Q_th=fx.Flow('Q_th', bus=Fernwaerme, size=200),\n        Q_fu=fx.Flow('Q_fu', bus=Kohle, size=288, relative_minimum=87 / 288, previous_flow_rate=100),\n    )\n\n    # 3. Storage\n    a_speicher = fx.Storage(\n        'Speicher',\n        capacity_in_flow_hours=684,\n        initial_charge_state=137,\n        minimal_final_charge_state=137,\n        maximal_final_charge_state=158,\n        eta_charge=1,\n        eta_discharge=1,\n        relative_loss_per_hour=0.001,\n        prevent_simultaneous_charge_and_discharge=True,\n        charging=fx.Flow('Q_th_load', size=137, bus=Fernwaerme),\n        discharging=fx.Flow('Q_th_unload', size=158, bus=Fernwaerme),\n    )\n\n    # 4. Sinks and Sources\n    # Heat Load Profile\n    a_waermelast = fx.Sink(\n        'W\u00e4rmelast', sink=fx.Flow('Q_th_Last', bus=Fernwaerme, size=1, fixed_relative_profile=TS_heat_demand)\n    )\n\n    # Electricity Feed-in\n    a_strom_last = fx.Sink(\n        'Stromlast', sink=fx.Flow('P_el_Last', bus=Strom, size=1, fixed_relative_profile=TS_electricity_demand)\n    )\n\n    # Gas Tariff\n    a_gas_tarif = fx.Source(\n        'Gastarif', source=fx.Flow('Q_Gas', bus=Gas, size=1000, effects_per_flow_hour={costs: gas_price, CO2: 0.3})\n    )\n\n    # Coal Tariff\n    a_kohle_tarif = fx.Source(\n        'Kohletarif', source=fx.Flow('Q_Kohle', bus=Kohle, size=1000, effects_per_flow_hour={costs: 4.6, CO2: 0.3})\n    )\n\n    # Electricity Tariff and Feed-in\n    a_strom_einspeisung = fx.Sink(\n        'Einspeisung', sink=fx.Flow('P_el', bus=Strom, size=1000, effects_per_flow_hour=TS_electricity_price_sell)\n    )\n\n    a_strom_tarif = fx.Source(\n        'Stromtarif',\n        source=fx.Flow('P_el', bus=Strom, size=1000, effects_per_flow_hour={costs: TS_electricity_price_buy, CO2: 0.3}),\n    )\n\n    # Flow System Setup\n    flow_system = fx.FlowSystem(datetime_series)\n    flow_system.add_effects(costs, CO2, PE)\n    flow_system.add_components(\n        a_gaskessel,\n        a_waermelast,\n        a_strom_last,\n        a_gas_tarif,\n        a_kohle_tarif,\n        a_strom_einspeisung,\n        a_strom_tarif,\n        a_kwk,\n        a_speicher,\n    )\n    flow_system.visualize_network(controls=False)\n    # Calculations\n    kinds = ['Full', 'Segmented', 'Aggregated']\n    calculations: dict = {key: None for key in kinds}\n    results: dict = {key: None for key in kinds}\n\n    if full:\n        calculation = fx.FullCalculation('fullModel', flow_system, 'pyomo')\n        calculation.do_modeling()\n        calculation.solve(fx.solvers.HighsSolver())\n        calculations['Full'] = calculation\n        results['Full'] = calculations['Full'].results()\n\n    if segmented:\n        calculation = fx.SegmentedCalculation('segModel', flow_system, segment_length, overlap_length)\n        calculation.do_modeling_and_solve(fx.solvers.HighsSolver())\n        calculations['Segmented'] = calculation\n        results['Segmented'] = calculations['Segmented'].results(combined_arrays=True)\n\n    if aggregated:\n        if keep_extreme_periods:\n            aggregation_parameters.time_series_for_high_peaks = [TS_heat_demand]\n            aggregation_parameters.time_series_for_low_peaks = [TS_electricity_demand, TS_heat_demand]\n        calculation = fx.AggregatedCalculation('aggModel', flow_system, aggregation_parameters)\n        calculation.do_modeling()\n        calculation.solve(fx.solvers.HighsSolver())\n        calculations['Aggregated'] = calculation\n        results['Aggregated'] = calculations['Aggregated'].results()\n    pprint(results)\n\n    def extract_result(results_data: dict[str, dict], keys: List[str]) -&gt; Dict[str, Union[int, float, np.ndarray]]:\n        \"\"\"\n        Function to retrieve values from a nested dictionary.\n        Tries to get the wanted value for eachnkey in the first layer of the dict.\n        Returns a dict with one key value pair for each dict it found a value in.\n        \"\"\"\n\n        def get_nested_value(d, ks):\n            for k in ks:\n                if isinstance(d, dict):\n                    d = d.get(k, None)\n                else:\n                    return None\n            return d\n\n        return {kind: get_nested_value(results_data.get(kind, {}), keys) for kind in results_data.keys()}\n\n    if calculations['Full'] is not None:\n        time_series_used = calculations['Full'].system_model.time_series\n        time_series_used_w_end = calculations['Full'].system_model.time_series_with_end\n    else:\n        time_series_used = calculations['Aggregated'].system_model.time_series\n        time_series_used_w_end = calculations['Aggregated'].system_model.time_series_with_end\n\n    data = pd.DataFrame(\n        extract_result(results, ['Components', 'Speicher', 'charge_state']), index=time_series_used_w_end\n    )\n    fig = fx.plotting.with_plotly(data, 'line')\n    fig.update_layout(title='Charge State Comparison', xaxis_title='Time', yaxis_title='Charge state')\n    fig.write_html('results/Charge State.html')\n\n    data = pd.DataFrame(extract_result(results, ['Components', 'BHKW2', 'Q_th', 'flow_rate']), index=time_series_used)\n    fig = fx.plotting.with_plotly(data, 'line')\n    fig.update_layout(title='BHKW2 Q_th Flow Rate Comparison', xaxis_title='Time', yaxis_title='Flow rate')\n    fig.write_html('results/BHKW2 Thermal Power.html')\n\n    data = pd.DataFrame(\n        extract_result(results, ['Effects', 'costs', 'operation', 'operation_sum_TS']),\n        index=calculations['Full'].system_model.time_series,\n    )\n    fig = fx.plotting.with_plotly(data, 'line')\n    fig.update_layout(title='Cost Comparison', xaxis_title='Time', yaxis_title='Costs (\u20ac)')\n    fig.write_html('results/Operation Costs.html')\n\n    data = pd.DataFrame(\n        extract_result(results, ['Effects', 'costs', 'operation', 'operation_sum_TS']), index=time_series_used\n    )\n    data = pd.DataFrame(data.sum()).T\n    fig = fx.plotting.with_plotly(data, 'bar')\n    fig.update_layout(title='Total Cost Comparison', yaxis_title='Costs (\u20ac)', barmode='group')\n    fig.write_html('results/Total Costs.html')\n\n    duration_data = pd.DataFrame(\n        {\n            'Full': [calculations['Full'].durations.get(key, 0) for key in calculations['Aggregated'].durations],\n            'Aggregated': [\n                calculations['Aggregated'].durations.get(key, 0) for key in calculations['Aggregated'].durations\n            ],\n            'Segmented': [\n                calculations['Segmented'].durations.get(key, 0) for key in calculations['Aggregated'].durations\n            ],\n        },\n        index=list(calculations['Aggregated'].durations.keys()),\n    ).T\n    fig = fx.plotting.with_plotly(duration_data, 'bar')\n    fig.update_layout(title='Duration Comparison', xaxis_title='Calculation type', yaxis_title='Time (s)')\n    fig.write_html('results/Speed Comparison.html')\n</code></pre></p>"}]}